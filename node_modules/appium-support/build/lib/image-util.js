"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MIME_PNG = exports.MIME_JPEG = exports.MIME_BMP = void 0;
exports.base64ToImage = base64ToImage;
exports.cropBase64Image = cropBase64Image;
exports.cropImage = cropImage;
exports.getImageOccurrence = getImageOccurrence;
exports.getImagesMatches = getImagesMatches;
exports.getImagesSimilarity = getImagesSimilarity;
exports.getJimpImage = getJimpImage;
exports.imageToBase64 = imageToBase64;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _jimp = _interopRequireDefault(require("jimp"));

var _buffer = require("buffer");

var _pngjs = require("pngjs");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _node = require("./node");

const {
  MIME_JPEG,
  MIME_PNG,
  MIME_BMP
} = _jimp.default;
exports.MIME_BMP = MIME_BMP;
exports.MIME_PNG = MIME_PNG;
exports.MIME_JPEG = MIME_JPEG;
let cv = null;
const BYTES_IN_PIXEL_BLOCK = 4;
const SCANLINE_FILTER_METHOD = 4;
const DEFAULT_MATCH_THRESHOLD = 0.5;
const MATCH_NEIGHBOUR_THRESHOLD = 10;
const AVAILABLE_DETECTORS = ['AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'];
const AVAILABLE_MATCHING_FUNCTIONS = ['FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2'];
const MATCHING_METHODS = ['TM_CCOEFF', 'TM_CCOEFF_NORMED', 'TM_CCORR', 'TM_CCORR_NORMED', 'TM_SQDIFF', 'TM_SQDIFF_NORMED'];
const DEFAULT_MATCHING_METHOD = 'TM_CCOEFF_NORMED';

function toMatchingMethod(name) {
  if (!MATCHING_METHODS.includes(name)) {
    throw new Error(`The matching method '${name}' is unknown. ` + `Only the following matching methods are supported: ${MATCHING_METHODS}`);
  }

  return cv[name];
}

async function getJimpImage(data) {
  return await new _bluebird.default((resolve, reject) => {
    if (!_lodash.default.isString(data) && !_lodash.default.isBuffer(data)) {
      return reject(new Error('Must initialize jimp object with string or buffer'));
    }

    if (_lodash.default.isString(data)) {
      data = _buffer.Buffer.from(data, 'base64');
    }

    new _jimp.default(data, (err, imgObj) => {
      if (err) {
        return reject(err);
      }

      if (!imgObj) {
        return reject(new Error('Could not create jimp image from that data'));
      }

      imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);
      imgObj.getBuffer = _bluebird.default.promisify(imgObj._getBuffer, {
        context: imgObj
      });
      resolve(imgObj);
    });
  });
}

async function initOpenCV() {
  if (cv) {
    return;
  }

  _logger.default.debug(`Initializing OpenCV`);

  for (const pkgName of ['@u4/opencv4nodejs', 'opencv4nodejs']) {
    try {
      cv = await (0, _node.requirePackage)(pkgName);
    } catch (err) {
      _logger.default.warn(`Unable to load '${pkgName}': ${err.message}`);
    }
  }

  if (!cv) {
    throw new Error(`'@u4/opencv4nodejs' module is required to use OpenCV features. ` + `Please install it first and restart Appium. ` + `Read https://github.com/appium/appium-plugins/pull/73#issuecomment-1013683074 and ` + `https://github.com/UrielCh/opencv4nodejs#fork-changes for more details on this topic.`);
  }
}

async function detectAndCompute(img, detector) {
  const keyPoints = await detector.detectAsync(img);
  const descriptor = await detector.computeAsync(img, keyPoints);
  return {
    keyPoints,
    descriptor
  };
}

function calculateMatchedRect(matchedPoints) {
  if (matchedPoints.length < 2) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  const pointsSortedByDistance = matchedPoints.map(point => [Math.sqrt(point.x * point.x + point.y * point.y), point]).sort((pair1, pair2) => pair1[0] >= pair2[0]).map(pair => pair[1]);

  const firstPoint = _lodash.default.head(pointsSortedByDistance);

  const lastPoint = _lodash.default.last(pointsSortedByDistance);

  const topLeftPoint = {
    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  const bottomRightPoint = {
    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  return {
    x: topLeftPoint.x,
    y: topLeftPoint.y,
    width: bottomRightPoint.x - topLeftPoint.x,
    height: bottomRightPoint.y - topLeftPoint.y
  };
}

function highlightRegion(mat, region) {
  if (region.width <= 0 || region.height <= 0) {
    return;
  }

  const color = new cv.Vec(0, 0, 255);
  const thickness = 2;
  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);
  return mat;
}

async function getImagesMatches(img1Data, img2Data, options = {}) {
  await initOpenCV();
  const {
    detectorName = 'ORB',
    visualize = false,
    goodMatchesFactor,
    matchFunc = 'BruteForce'
  } = options;

  if (!_lodash.default.includes(AVAILABLE_DETECTORS, detectorName)) {
    throw new Error(`'${detectorName}' detector is unknown. ` + `Only ${JSON.stringify(AVAILABLE_DETECTORS)} detectors are supported.`);
  }

  if (!_lodash.default.includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {
    throw new Error(`'${matchFunc}' matching function is unknown. ` + `Only ${JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS)} matching functions are supported.`);
  }

  const detector = new cv[`${detectorName}Detector`]();
  const [img1, img2] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);
  const [result1, result2] = await _bluebird.default.all([detectAndCompute(img1, detector), detectAndCompute(img2, detector)]);
  let matches = [];

  try {
    matches = await cv[`match${matchFunc}Async`](result1.descriptor, result2.descriptor);
  } catch (e) {
    throw new Error(`Cannot find any matches between the given images. Try another detection algorithm. ` + ` Original error: ${e}`);
  }

  const totalCount = matches.length;

  if ((0, _util.hasValue)(goodMatchesFactor)) {
    if (_lodash.default.isFunction(goodMatchesFactor)) {
      const distances = matches.map(match => match.distance);

      const minDistance = _lodash.default.min(distances);

      const maxDistance = _lodash.default.max(distances);

      matches = matches.filter(match => goodMatchesFactor(match.distance, minDistance, maxDistance));
    } else {
      if (matches.length > goodMatchesFactor) {
        matches = matches.sort((match1, match2) => match1.distance - match2.distance).slice(0, goodMatchesFactor);
      }
    }
  }

  const extractPoint = (keyPoints, indexPropertyName) => match => {
    const {
      pt,
      point
    } = keyPoints[match[indexPropertyName]];
    return pt || point;
  };

  const points1 = matches.map(extractPoint(result1.keyPoints, 'queryIdx'));
  const rect1 = calculateMatchedRect(points1);
  const points2 = matches.map(extractPoint(result2.keyPoints, 'trainIdx'));
  const rect2 = calculateMatchedRect(points2);
  const result = {
    points1,
    rect1,
    points2,
    rect2,
    totalCount,
    count: matches.length
  };

  if (visualize) {
    const visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);
    highlightRegion(visualization, rect1);
    highlightRegion(visualization, {
      x: img1.cols + rect2.x,
      y: rect2.y,
      width: rect2.width,
      height: rect2.height
    });
    result.visualization = await cv.imencodeAsync('.png', visualization);
  }

  return result;
}

async function getImagesSimilarity(img1Data, img2Data, options = {}) {
  await initOpenCV();
  const {
    method = DEFAULT_MATCHING_METHOD,
    visualize = false
  } = options;
  let [template, reference] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);

  if (template.rows !== reference.rows || template.cols !== reference.cols) {
    throw new Error('Both images are expected to have the same size in order to ' + 'calculate the similarity score.');
  }

  [template, reference] = await _bluebird.default.all([template.convertToAsync(cv.CV_8UC3), reference.convertToAsync(cv.CV_8UC3)]);
  let matched;

  try {
    matched = await reference.matchTemplateAsync(template, toMatchingMethod(method));
  } catch (e) {
    throw new Error(`The reference image did not match to the template one. Original error: ${e.message}`);
  }

  const minMax = await matched.minMaxLocAsync();
  const result = {
    score: minMax.maxVal
  };

  if (visualize) {
    const resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);
    await _bluebird.default.all([reference.copyToAsync(resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))), template.copyToAsync(resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))]);
    let mask = reference.absdiff(template);
    mask = await mask.cvtColorAsync(cv.COLOR_BGR2GRAY);
    let contours = [];

    try {
      mask = await mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
      contours = await mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    } catch (ign) {}

    for (const contour of contours) {
      const boundingRect = contour.boundingRect();
      highlightRegion(resultMat, boundingRect);
      highlightRegion(resultMat, {
        x: reference.cols + boundingRect.x,
        y: boundingRect.y,
        width: boundingRect.width,
        height: boundingRect.height
      });
    }

    result.visualization = await cv.imencodeAsync('.png', resultMat);
  }

  return result;
}

async function getImageOccurrence(fullImgData, partialImgData, options = {}) {
  await initOpenCV();
  const {
    visualize = false,
    threshold = DEFAULT_MATCH_THRESHOLD,
    multiple = false,
    matchNeighbourThreshold = MATCH_NEIGHBOUR_THRESHOLD,
    method = DEFAULT_MATCHING_METHOD
  } = options;
  const [fullImg, partialImg] = await _bluebird.default.all([cv.imdecodeAsync(fullImgData), cv.imdecodeAsync(partialImgData)]);
  const results = [];
  let visualization = null;

  try {
    const matched = await fullImg.matchTemplateAsync(partialImg, toMatchingMethod(method));
    const minMax = await matched.minMaxLocAsync();

    if (multiple) {
      const nonZeroMatchResults = matched.threshold(threshold, 1, cv.THRESH_BINARY).convertTo(cv.CV_8U).findNonZero();
      const matches = filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold);

      for (const {
        x,
        y
      } of matches) {
        results.push({
          score: matched.at(y, x),
          rect: {
            x,
            y,
            width: partialImg.cols,
            height: partialImg.rows
          }
        });
      }
    } else if (minMax.maxVal >= threshold) {
      const {
        x,
        y
      } = method.includes('SQDIFF') ? minMax.minLoc : minMax.maxLoc;
      results.push({
        score: minMax.maxVal,
        rect: {
          x,
          y,
          width: partialImg.cols,
          height: partialImg.rows
        }
      });
    }

    if (_lodash.default.isEmpty(results)) {
      throw new Error(`Match threshold: ${threshold}. Highest match value ` + `found was ${minMax.maxVal}`);
    }
  } catch (e) {
    throw new Error(`Cannot find any occurrences of the partial image in the full image. ` + `Original error: ${e.message}`);
  }

  if (visualize) {
    const fullHighlightedImage = fullImg.copy();

    for (const result of results) {
      const singleHighlightedImage = fullImg.copy();
      highlightRegion(singleHighlightedImage, result.rect);
      highlightRegion(fullHighlightedImage, result.rect);
      result.visualization = await cv.imencodeAsync('.png', singleHighlightedImage);
    }

    visualization = await cv.imencodeAsync('.png', fullHighlightedImage);
  }

  return {
    rect: results[0].rect,
    score: results[0].score,
    visualization,
    multiple: results
  };
}

function filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold) {
  return nonZeroMatchResults.reduce((acc, element) => {
    if (!acc.some(match => distance(match, element) <= matchNeighbourThreshold)) {
      acc.push(element);
    }

    return acc;
  }, []);
}

function distance(point1, point2) {
  const a2 = Math.pow(point1.x - point2.x, 2);
  const b2 = Math.pow(point1.y - point2.y, 2);
  return Math.sqrt(a2 + b2);
}

async function cropBase64Image(base64Image, rect) {
  const image = await base64ToImage(base64Image);
  cropImage(image, rect);
  return await imageToBase64(image);
}

async function base64ToImage(base64Image) {
  const imageBuffer = _buffer.Buffer.from(base64Image, 'base64');

  return await new _bluebird.default((resolve, reject) => {
    const image = new _pngjs.PNG({
      filterType: SCANLINE_FILTER_METHOD
    });
    image.parse(imageBuffer, (err, image) => {
      if (err) {
        return reject(err);
      }

      resolve(image);
    });
  });
}

async function imageToBase64(image) {
  return await new _bluebird.default((resolve, reject) => {
    const chunks = [];
    image.pack().on('data', chunk => chunks.push(chunk)).on('end', () => {
      resolve(_buffer.Buffer.concat(chunks).toString('base64'));
    }).on('error', err => {
      reject(err);
    });
  });
}

function cropImage(image, rect) {
  const imageRect = {
    width: image.width,
    height: image.height
  };
  const interRect = getRectIntersection(rect, imageRect);

  if (interRect.width < rect.width || interRect.height < rect.height) {
    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);
  }

  const firstVerticalPixel = interRect.top;
  const lastVerticalPixel = interRect.top + interRect.height;
  const firstHorizontalPixel = interRect.left;
  const lastHorizontalPixel = interRect.left + interRect.width;
  const croppedArray = [];

  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {
    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {
      const firstByteIdxInPixelBlock = imageRect.width * y + x << 2;

      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {
        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);
      }
    }
  }

  image.data = _buffer.Buffer.from(croppedArray);
  image.width = interRect.width;
  image.height = interRect.height;
  return image;
}

function getRectIntersection(rect, imageSize) {
  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;
  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;
  const width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;
  const height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;
  return {
    left,
    top,
    width,
    height
  };
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pbWFnZS11dGlsLmpzIl0sIm5hbWVzIjpbIk1JTUVfSlBFRyIsIk1JTUVfUE5HIiwiTUlNRV9CTVAiLCJKaW1wIiwiY3YiLCJCWVRFU19JTl9QSVhFTF9CTE9DSyIsIlNDQU5MSU5FX0ZJTFRFUl9NRVRIT0QiLCJERUZBVUxUX01BVENIX1RIUkVTSE9MRCIsIk1BVENIX05FSUdIQk9VUl9USFJFU0hPTEQiLCJBVkFJTEFCTEVfREVURUNUT1JTIiwiQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUyIsIk1BVENISU5HX01FVEhPRFMiLCJERUZBVUxUX01BVENISU5HX01FVEhPRCIsInRvTWF0Y2hpbmdNZXRob2QiLCJuYW1lIiwiaW5jbHVkZXMiLCJFcnJvciIsImdldEppbXBJbWFnZSIsImRhdGEiLCJCIiwicmVzb2x2ZSIsInJlamVjdCIsIl8iLCJpc1N0cmluZyIsImlzQnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImVyciIsImltZ09iaiIsIl9nZXRCdWZmZXIiLCJnZXRCdWZmZXIiLCJiaW5kIiwicHJvbWlzaWZ5IiwiY29udGV4dCIsImluaXRPcGVuQ1YiLCJsb2ciLCJkZWJ1ZyIsInBrZ05hbWUiLCJ3YXJuIiwibWVzc2FnZSIsImRldGVjdEFuZENvbXB1dGUiLCJpbWciLCJkZXRlY3RvciIsImtleVBvaW50cyIsImRldGVjdEFzeW5jIiwiZGVzY3JpcHRvciIsImNvbXB1dGVBc3luYyIsImNhbGN1bGF0ZU1hdGNoZWRSZWN0IiwibWF0Y2hlZFBvaW50cyIsImxlbmd0aCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJwb2ludHNTb3J0ZWRCeURpc3RhbmNlIiwibWFwIiwicG9pbnQiLCJNYXRoIiwic3FydCIsInNvcnQiLCJwYWlyMSIsInBhaXIyIiwicGFpciIsImZpcnN0UG9pbnQiLCJoZWFkIiwibGFzdFBvaW50IiwibGFzdCIsInRvcExlZnRQb2ludCIsImJvdHRvbVJpZ2h0UG9pbnQiLCJoaWdobGlnaHRSZWdpb24iLCJtYXQiLCJyZWdpb24iLCJjb2xvciIsIlZlYyIsInRoaWNrbmVzcyIsImRyYXdSZWN0YW5nbGUiLCJSZWN0IiwiTElORV84IiwiZ2V0SW1hZ2VzTWF0Y2hlcyIsImltZzFEYXRhIiwiaW1nMkRhdGEiLCJvcHRpb25zIiwiZGV0ZWN0b3JOYW1lIiwidmlzdWFsaXplIiwiZ29vZE1hdGNoZXNGYWN0b3IiLCJtYXRjaEZ1bmMiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1nMSIsImltZzIiLCJhbGwiLCJpbWRlY29kZUFzeW5jIiwicmVzdWx0MSIsInJlc3VsdDIiLCJtYXRjaGVzIiwiZSIsInRvdGFsQ291bnQiLCJpc0Z1bmN0aW9uIiwiZGlzdGFuY2VzIiwibWF0Y2giLCJkaXN0YW5jZSIsIm1pbkRpc3RhbmNlIiwibWluIiwibWF4RGlzdGFuY2UiLCJtYXgiLCJmaWx0ZXIiLCJtYXRjaDEiLCJtYXRjaDIiLCJzbGljZSIsImV4dHJhY3RQb2ludCIsImluZGV4UHJvcGVydHlOYW1lIiwicHQiLCJwb2ludHMxIiwicmVjdDEiLCJwb2ludHMyIiwicmVjdDIiLCJyZXN1bHQiLCJjb3VudCIsInZpc3VhbGl6YXRpb24iLCJkcmF3TWF0Y2hlcyIsImNvbHMiLCJpbWVuY29kZUFzeW5jIiwiZ2V0SW1hZ2VzU2ltaWxhcml0eSIsIm1ldGhvZCIsInRlbXBsYXRlIiwicmVmZXJlbmNlIiwicm93cyIsImNvbnZlcnRUb0FzeW5jIiwiQ1ZfOFVDMyIsIm1hdGNoZWQiLCJtYXRjaFRlbXBsYXRlQXN5bmMiLCJtaW5NYXgiLCJtaW5NYXhMb2NBc3luYyIsInNjb3JlIiwibWF4VmFsIiwicmVzdWx0TWF0IiwiTWF0IiwiY29weVRvQXN5bmMiLCJnZXRSZWdpb24iLCJtYXNrIiwiYWJzZGlmZiIsImN2dENvbG9yQXN5bmMiLCJDT0xPUl9CR1IyR1JBWSIsImNvbnRvdXJzIiwidGhyZXNob2xkQXN5bmMiLCJUSFJFU0hfQklOQVJZIiwiVEhSRVNIX09UU1UiLCJmaW5kQ29udG91cnNBc3luYyIsIlJFVFJfRVhURVJOQUwiLCJDSEFJTl9BUFBST1hfU0lNUExFIiwiaWduIiwiY29udG91ciIsImJvdW5kaW5nUmVjdCIsImdldEltYWdlT2NjdXJyZW5jZSIsImZ1bGxJbWdEYXRhIiwicGFydGlhbEltZ0RhdGEiLCJ0aHJlc2hvbGQiLCJtdWx0aXBsZSIsIm1hdGNoTmVpZ2hib3VyVGhyZXNob2xkIiwiZnVsbEltZyIsInBhcnRpYWxJbWciLCJyZXN1bHRzIiwibm9uWmVyb01hdGNoUmVzdWx0cyIsImNvbnZlcnRUbyIsIkNWXzhVIiwiZmluZE5vblplcm8iLCJmaWx0ZXJOZWFyTWF0Y2hlcyIsInB1c2giLCJhdCIsInJlY3QiLCJtaW5Mb2MiLCJtYXhMb2MiLCJpc0VtcHR5IiwiZnVsbEhpZ2hsaWdodGVkSW1hZ2UiLCJjb3B5Iiwic2luZ2xlSGlnaGxpZ2h0ZWRJbWFnZSIsInJlZHVjZSIsImFjYyIsImVsZW1lbnQiLCJzb21lIiwicG9pbnQxIiwicG9pbnQyIiwiYTIiLCJwb3ciLCJiMiIsImNyb3BCYXNlNjRJbWFnZSIsImJhc2U2NEltYWdlIiwiaW1hZ2UiLCJiYXNlNjRUb0ltYWdlIiwiY3JvcEltYWdlIiwiaW1hZ2VUb0Jhc2U2NCIsImltYWdlQnVmZmVyIiwiUE5HIiwiZmlsdGVyVHlwZSIsInBhcnNlIiwiY2h1bmtzIiwicGFjayIsIm9uIiwiY2h1bmsiLCJjb25jYXQiLCJ0b1N0cmluZyIsImltYWdlUmVjdCIsImludGVyUmVjdCIsImdldFJlY3RJbnRlcnNlY3Rpb24iLCJmaXJzdFZlcnRpY2FsUGl4ZWwiLCJ0b3AiLCJsYXN0VmVydGljYWxQaXhlbCIsImZpcnN0SG9yaXpvbnRhbFBpeGVsIiwibGVmdCIsImxhc3RIb3Jpem9udGFsUGl4ZWwiLCJjcm9wcGVkQXJyYXkiLCJmaXJzdEJ5dGVJZHhJblBpeGVsQmxvY2siLCJieXRlSWR4IiwiaW1hZ2VTaXplIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsTUFBTTtBQUFFQSxFQUFBQSxTQUFGO0FBQWFDLEVBQUFBLFFBQWI7QUFBdUJDLEVBQUFBO0FBQXZCLElBQW9DQyxhQUExQzs7OztBQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFUO0FBd0JBLE1BQU1DLG9CQUFvQixHQUFHLENBQTdCO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsQ0FBL0I7QUFDQSxNQUFNQyx1QkFBdUIsR0FBRyxHQUFoQztBQUNBLE1BQU1DLHlCQUF5QixHQUFHLEVBQWxDO0FBRUEsTUFBTUMsbUJBQW1CLEdBQUcsQ0FDMUIsT0FEMEIsRUFFMUIsT0FGMEIsRUFHMUIsT0FIMEIsRUFJMUIsTUFKMEIsRUFLMUIsTUFMMEIsRUFNMUIsTUFOMEIsRUFPMUIsTUFQMEIsRUFRMUIsTUFSMEIsRUFTMUIsS0FUMEIsQ0FBNUI7QUFZQSxNQUFNQyw0QkFBNEIsR0FBRyxDQUNuQyxZQURtQyxFQUVuQyxZQUZtQyxFQUduQyxjQUhtQyxFQUluQyxtQkFKbUMsRUFLbkMsc0JBTG1DLEVBTW5DLGVBTm1DLENBQXJDO0FBU0EsTUFBTUMsZ0JBQWdCLEdBQUcsQ0FDdkIsV0FEdUIsRUFFdkIsa0JBRnVCLEVBR3ZCLFVBSHVCLEVBSXZCLGlCQUp1QixFQUt2QixXQUx1QixFQU12QixrQkFOdUIsQ0FBekI7QUFRQSxNQUFNQyx1QkFBdUIsR0FBRyxrQkFBaEM7O0FBV0EsU0FBU0MsZ0JBQVQsQ0FBMkJDLElBQTNCLEVBQWlDO0FBQy9CLE1BQUksQ0FBQ0gsZ0JBQWdCLENBQUNJLFFBQWpCLENBQTBCRCxJQUExQixDQUFMLEVBQXNDO0FBQ3BDLFVBQU0sSUFBSUUsS0FBSixDQUFXLHdCQUF1QkYsSUFBSyxnQkFBN0IsR0FDYixzREFBcURILGdCQUFpQixFQURuRSxDQUFOO0FBRUQ7O0FBQ0QsU0FBT1AsRUFBRSxDQUFDVSxJQUFELENBQVQ7QUFDRDs7QUFXRCxlQUFlRyxZQUFmLENBQTZCQyxJQUE3QixFQUFtQztBQUNqQyxTQUFPLE1BQU0sSUFBSUMsaUJBQUosQ0FBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMsUUFBSSxDQUFDQyxnQkFBRUMsUUFBRixDQUFXTCxJQUFYLENBQUQsSUFBcUIsQ0FBQ0ksZ0JBQUVFLFFBQUYsQ0FBV04sSUFBWCxDQUExQixFQUE0QztBQUMxQyxhQUFPRyxNQUFNLENBQUMsSUFBSUwsS0FBSixDQUFVLG1EQUFWLENBQUQsQ0FBYjtBQUNEOztBQUVELFFBQUlNLGdCQUFFQyxRQUFGLENBQVdMLElBQVgsQ0FBSixFQUFzQjtBQUNwQkEsTUFBQUEsSUFBSSxHQUFHTyxlQUFPQyxJQUFQLENBQVlSLElBQVosRUFBa0IsUUFBbEIsQ0FBUDtBQUNEOztBQUNELFFBQUlmLGFBQUosQ0FBU2UsSUFBVCxFQUFlLENBQUNTLEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUM5QixVQUFJRCxHQUFKLEVBQVM7QUFDUCxlQUFPTixNQUFNLENBQUNNLEdBQUQsQ0FBYjtBQUNEOztBQUNELFVBQUksQ0FBQ0MsTUFBTCxFQUFhO0FBQ1gsZUFBT1AsTUFBTSxDQUFDLElBQUlMLEtBQUosQ0FBVSw0Q0FBVixDQUFELENBQWI7QUFDRDs7QUFDRFksTUFBQUEsTUFBTSxDQUFDQyxVQUFQLEdBQW9CRCxNQUFNLENBQUNFLFNBQVAsQ0FBaUJDLElBQWpCLENBQXNCSCxNQUF0QixDQUFwQjtBQUNBQSxNQUFBQSxNQUFNLENBQUNFLFNBQVAsR0FBbUJYLGtCQUFFYSxTQUFGLENBQVlKLE1BQU0sQ0FBQ0MsVUFBbkIsRUFBK0I7QUFBQ0ksUUFBQUEsT0FBTyxFQUFFTDtBQUFWLE9BQS9CLENBQW5CO0FBQ0FSLE1BQUFBLE9BQU8sQ0FBQ1EsTUFBRCxDQUFQO0FBQ0QsS0FWRDtBQVdELEdBbkJZLENBQWI7QUFvQkQ7O0FBS0QsZUFBZU0sVUFBZixHQUE2QjtBQUMzQixNQUFJOUIsRUFBSixFQUFRO0FBQ047QUFDRDs7QUFFRCtCLGtCQUFJQyxLQUFKLENBQVcscUJBQVg7O0FBQ0EsT0FBSyxNQUFNQyxPQUFYLElBQXNCLENBQUMsbUJBQUQsRUFBc0IsZUFBdEIsQ0FBdEIsRUFBOEQ7QUFDNUQsUUFBSTtBQUNGakMsTUFBQUEsRUFBRSxHQUFHLE1BQU0sMEJBQWVpQyxPQUFmLENBQVg7QUFDRCxLQUZELENBRUUsT0FBT1YsR0FBUCxFQUFZO0FBQ1pRLHNCQUFJRyxJQUFKLENBQVUsbUJBQWtCRCxPQUFRLE1BQUtWLEdBQUcsQ0FBQ1ksT0FBUSxFQUFyRDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDbkMsRUFBTCxFQUFTO0FBQ1AsVUFBTSxJQUFJWSxLQUFKLENBQVcsaUVBQUQsR0FDYiw4Q0FEYSxHQUViLG9GQUZhLEdBR2IsdUZBSEcsQ0FBTjtBQUlEO0FBQ0Y7O0FBbUJELGVBQWV3QixnQkFBZixDQUFpQ0MsR0FBakMsRUFBc0NDLFFBQXRDLEVBQWdEO0FBQzlDLFFBQU1DLFNBQVMsR0FBRyxNQUFNRCxRQUFRLENBQUNFLFdBQVQsQ0FBcUJILEdBQXJCLENBQXhCO0FBQ0EsUUFBTUksVUFBVSxHQUFHLE1BQU1ILFFBQVEsQ0FBQ0ksWUFBVCxDQUFzQkwsR0FBdEIsRUFBMkJFLFNBQTNCLENBQXpCO0FBQ0EsU0FBTztBQUNMQSxJQUFBQSxTQURLO0FBRUxFLElBQUFBO0FBRkssR0FBUDtBQUlEOztBQVNELFNBQVNFLG9CQUFULENBQStCQyxhQUEvQixFQUE4QztBQUM1QyxNQUFJQSxhQUFhLENBQUNDLE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUIsV0FBTztBQUNMQyxNQUFBQSxDQUFDLEVBQUUsQ0FERTtBQUVMQyxNQUFBQSxDQUFDLEVBQUUsQ0FGRTtBQUdMQyxNQUFBQSxLQUFLLEVBQUUsQ0FIRjtBQUlMQyxNQUFBQSxNQUFNLEVBQUU7QUFKSCxLQUFQO0FBTUQ7O0FBRUQsUUFBTUMsc0JBQXNCLEdBQUdOLGFBQWEsQ0FDekNPLEdBRDRCLENBQ3ZCQyxLQUFELElBQVcsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFMLENBQVVGLEtBQUssQ0FBQ04sQ0FBTixHQUFVTSxLQUFLLENBQUNOLENBQWhCLEdBQW9CTSxLQUFLLENBQUNMLENBQU4sR0FBVUssS0FBSyxDQUFDTCxDQUE5QyxDQUFELEVBQW1ESyxLQUFuRCxDQURhLEVBRTVCRyxJQUY0QixDQUV2QixDQUFDQyxLQUFELEVBQVFDLEtBQVIsS0FBa0JELEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWUMsS0FBSyxDQUFDLENBQUQsQ0FGWixFQUc1Qk4sR0FINEIsQ0FHdkJPLElBQUQsSUFBVUEsSUFBSSxDQUFDLENBQUQsQ0FIVSxDQUEvQjs7QUFJQSxRQUFNQyxVQUFVLEdBQUd6QyxnQkFBRTBDLElBQUYsQ0FBT1Ysc0JBQVAsQ0FBbkI7O0FBQ0EsUUFBTVcsU0FBUyxHQUFHM0MsZ0JBQUU0QyxJQUFGLENBQU9aLHNCQUFQLENBQWxCOztBQUNBLFFBQU1hLFlBQVksR0FBRztBQUNuQmpCLElBQUFBLENBQUMsRUFBRWEsVUFBVSxDQUFDYixDQUFYLElBQWdCZSxTQUFTLENBQUNmLENBQTFCLEdBQThCYSxVQUFVLENBQUNiLENBQXpDLEdBQTZDZSxTQUFTLENBQUNmLENBRHZDO0FBRW5CQyxJQUFBQSxDQUFDLEVBQUVZLFVBQVUsQ0FBQ1osQ0FBWCxJQUFnQmMsU0FBUyxDQUFDZCxDQUExQixHQUE4QlksVUFBVSxDQUFDWixDQUF6QyxHQUE2Q2MsU0FBUyxDQUFDZDtBQUZ2QyxHQUFyQjtBQUlBLFFBQU1pQixnQkFBZ0IsR0FBRztBQUN2QmxCLElBQUFBLENBQUMsRUFBRWEsVUFBVSxDQUFDYixDQUFYLElBQWdCZSxTQUFTLENBQUNmLENBQTFCLEdBQThCYSxVQUFVLENBQUNiLENBQXpDLEdBQTZDZSxTQUFTLENBQUNmLENBRG5DO0FBRXZCQyxJQUFBQSxDQUFDLEVBQUVZLFVBQVUsQ0FBQ1osQ0FBWCxJQUFnQmMsU0FBUyxDQUFDZCxDQUExQixHQUE4QlksVUFBVSxDQUFDWixDQUF6QyxHQUE2Q2MsU0FBUyxDQUFDZDtBQUZuQyxHQUF6QjtBQUlBLFNBQU87QUFDTEQsSUFBQUEsQ0FBQyxFQUFFaUIsWUFBWSxDQUFDakIsQ0FEWDtBQUVMQyxJQUFBQSxDQUFDLEVBQUVnQixZQUFZLENBQUNoQixDQUZYO0FBR0xDLElBQUFBLEtBQUssRUFBRWdCLGdCQUFnQixDQUFDbEIsQ0FBakIsR0FBcUJpQixZQUFZLENBQUNqQixDQUhwQztBQUlMRyxJQUFBQSxNQUFNLEVBQUVlLGdCQUFnQixDQUFDakIsQ0FBakIsR0FBcUJnQixZQUFZLENBQUNoQjtBQUpyQyxHQUFQO0FBTUQ7O0FBVUQsU0FBU2tCLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCQyxNQUEvQixFQUF1QztBQUNyQyxNQUFJQSxNQUFNLENBQUNuQixLQUFQLElBQWdCLENBQWhCLElBQXFCbUIsTUFBTSxDQUFDbEIsTUFBUCxJQUFpQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUdELFFBQU1tQixLQUFLLEdBQUcsSUFBSXBFLEVBQUUsQ0FBQ3FFLEdBQVAsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixHQUFqQixDQUFkO0FBQ0EsUUFBTUMsU0FBUyxHQUFHLENBQWxCO0FBQ0FKLEVBQUFBLEdBQUcsQ0FBQ0ssYUFBSixDQUFrQixJQUFJdkUsRUFBRSxDQUFDd0UsSUFBUCxDQUFZTCxNQUFNLENBQUNyQixDQUFuQixFQUFzQnFCLE1BQU0sQ0FBQ3BCLENBQTdCLEVBQWdDb0IsTUFBTSxDQUFDbkIsS0FBdkMsRUFBOENtQixNQUFNLENBQUNsQixNQUFyRCxDQUFsQixFQUFnRm1CLEtBQWhGLEVBQXVGRSxTQUF2RixFQUFrR3RFLEVBQUUsQ0FBQ3lFLE1BQXJHO0FBQ0EsU0FBT1AsR0FBUDtBQUNEOztBQWdERCxlQUFlUSxnQkFBZixDQUFpQ0MsUUFBakMsRUFBMkNDLFFBQTNDLEVBQXFEQyxPQUFPLEdBQUcsRUFBL0QsRUFBbUU7QUFDakUsUUFBTS9DLFVBQVUsRUFBaEI7QUFFQSxRQUFNO0FBQUNnRCxJQUFBQSxZQUFZLEdBQUcsS0FBaEI7QUFBdUJDLElBQUFBLFNBQVMsR0FBRyxLQUFuQztBQUNDQyxJQUFBQSxpQkFERDtBQUNvQkMsSUFBQUEsU0FBUyxHQUFHO0FBRGhDLE1BQ2dESixPQUR0RDs7QUFFQSxNQUFJLENBQUMzRCxnQkFBRVAsUUFBRixDQUFXTixtQkFBWCxFQUFnQ3lFLFlBQWhDLENBQUwsRUFBb0Q7QUFDbEQsVUFBTSxJQUFJbEUsS0FBSixDQUFXLElBQUdrRSxZQUFhLHlCQUFqQixHQUNDLFFBQU9JLElBQUksQ0FBQ0MsU0FBTCxDQUFlOUUsbUJBQWYsQ0FBb0MsMkJBRHRELENBQU47QUFFRDs7QUFDRCxNQUFJLENBQUNhLGdCQUFFUCxRQUFGLENBQVdMLDRCQUFYLEVBQXlDMkUsU0FBekMsQ0FBTCxFQUEwRDtBQUN4RCxVQUFNLElBQUlyRSxLQUFKLENBQVcsSUFBR3FFLFNBQVUsa0NBQWQsR0FDQyxRQUFPQyxJQUFJLENBQUNDLFNBQUwsQ0FBZTdFLDRCQUFmLENBQTZDLG9DQUQvRCxDQUFOO0FBRUQ7O0FBRUQsUUFBTWdDLFFBQVEsR0FBRyxJQUFJdEMsRUFBRSxDQUFFLEdBQUU4RSxZQUFhLFVBQWpCLENBQU4sRUFBakI7QUFDQSxRQUFNLENBQUNNLElBQUQsRUFBT0MsSUFBUCxJQUFlLE1BQU10RSxrQkFBRXVFLEdBQUYsQ0FBTSxDQUMvQnRGLEVBQUUsQ0FBQ3VGLGFBQUgsQ0FBaUJaLFFBQWpCLENBRCtCLEVBRS9CM0UsRUFBRSxDQUFDdUYsYUFBSCxDQUFpQlgsUUFBakIsQ0FGK0IsQ0FBTixDQUEzQjtBQUlBLFFBQU0sQ0FBQ1ksT0FBRCxFQUFVQyxPQUFWLElBQXFCLE1BQU0xRSxrQkFBRXVFLEdBQUYsQ0FBTSxDQUNyQ2xELGdCQUFnQixDQUFDZ0QsSUFBRCxFQUFPOUMsUUFBUCxDQURxQixFQUVyQ0YsZ0JBQWdCLENBQUNpRCxJQUFELEVBQU8vQyxRQUFQLENBRnFCLENBQU4sQ0FBakM7QUFJQSxNQUFJb0QsT0FBTyxHQUFHLEVBQWQ7O0FBQ0EsTUFBSTtBQUNGQSxJQUFBQSxPQUFPLEdBQUcsTUFBTTFGLEVBQUUsQ0FBRSxRQUFPaUYsU0FBVSxPQUFuQixDQUFGLENBQTZCTyxPQUFPLENBQUMvQyxVQUFyQyxFQUFpRGdELE9BQU8sQ0FBQ2hELFVBQXpELENBQWhCO0FBQ0QsR0FGRCxDQUVFLE9BQU9rRCxDQUFQLEVBQVU7QUFDVixVQUFNLElBQUkvRSxLQUFKLENBQVcscUZBQUQsR0FDQyxvQkFBbUIrRSxDQUFFLEVBRGhDLENBQU47QUFFRDs7QUFDRCxRQUFNQyxVQUFVLEdBQUdGLE9BQU8sQ0FBQzdDLE1BQTNCOztBQUNBLE1BQUksb0JBQVNtQyxpQkFBVCxDQUFKLEVBQWlDO0FBQy9CLFFBQUk5RCxnQkFBRTJFLFVBQUYsQ0FBYWIsaUJBQWIsQ0FBSixFQUFxQztBQUNuQyxZQUFNYyxTQUFTLEdBQUdKLE9BQU8sQ0FBQ3ZDLEdBQVIsQ0FBYTRDLEtBQUQsSUFBV0EsS0FBSyxDQUFDQyxRQUE3QixDQUFsQjs7QUFDQSxZQUFNQyxXQUFXLEdBQUcvRSxnQkFBRWdGLEdBQUYsQ0FBTUosU0FBTixDQUFwQjs7QUFDQSxZQUFNSyxXQUFXLEdBQUdqRixnQkFBRWtGLEdBQUYsQ0FBTU4sU0FBTixDQUFwQjs7QUFDQUosTUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQ2RXLE1BRE8sQ0FDQ04sS0FBRCxJQUFXZixpQkFBaUIsQ0FBQ2UsS0FBSyxDQUFDQyxRQUFQLEVBQWlCQyxXQUFqQixFQUE4QkUsV0FBOUIsQ0FENUIsQ0FBVjtBQUVELEtBTkQsTUFNTztBQUNMLFVBQUlULE9BQU8sQ0FBQzdDLE1BQVIsR0FBaUJtQyxpQkFBckIsRUFBd0M7QUFDdENVLFFBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUNkbkMsSUFETyxDQUNGLENBQUMrQyxNQUFELEVBQVNDLE1BQVQsS0FBb0JELE1BQU0sQ0FBQ04sUUFBUCxHQUFrQk8sTUFBTSxDQUFDUCxRQUQzQyxFQUVQUSxLQUZPLENBRUQsQ0FGQyxFQUVFeEIsaUJBRkYsQ0FBVjtBQUdEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFNeUIsWUFBWSxHQUFHLENBQUNsRSxTQUFELEVBQVltRSxpQkFBWixLQUFtQ1gsS0FBRCxJQUFXO0FBQ2hFLFVBQU07QUFBQ1ksTUFBQUEsRUFBRDtBQUFLdkQsTUFBQUE7QUFBTCxRQUFjYixTQUFTLENBQUN3RCxLQUFLLENBQUNXLGlCQUFELENBQU4sQ0FBN0I7QUFFQSxXQUFRQyxFQUFFLElBQUl2RCxLQUFkO0FBQ0QsR0FKRDs7QUFLQSxRQUFNd0QsT0FBTyxHQUFHbEIsT0FBTyxDQUFDdkMsR0FBUixDQUFZc0QsWUFBWSxDQUFDakIsT0FBTyxDQUFDakQsU0FBVCxFQUFvQixVQUFwQixDQUF4QixDQUFoQjtBQUNBLFFBQU1zRSxLQUFLLEdBQUdsRSxvQkFBb0IsQ0FBQ2lFLE9BQUQsQ0FBbEM7QUFDQSxRQUFNRSxPQUFPLEdBQUdwQixPQUFPLENBQUN2QyxHQUFSLENBQVlzRCxZQUFZLENBQUNoQixPQUFPLENBQUNsRCxTQUFULEVBQW9CLFVBQXBCLENBQXhCLENBQWhCO0FBQ0EsUUFBTXdFLEtBQUssR0FBR3BFLG9CQUFvQixDQUFDbUUsT0FBRCxDQUFsQztBQUVBLFFBQU1FLE1BQU0sR0FBRztBQUNiSixJQUFBQSxPQURhO0FBRWJDLElBQUFBLEtBRmE7QUFHYkMsSUFBQUEsT0FIYTtBQUliQyxJQUFBQSxLQUphO0FBS2JuQixJQUFBQSxVQUxhO0FBTWJxQixJQUFBQSxLQUFLLEVBQUV2QixPQUFPLENBQUM3QztBQU5GLEdBQWY7O0FBUUEsTUFBSWtDLFNBQUosRUFBZTtBQUNiLFVBQU1tQyxhQUFhLEdBQUdsSCxFQUFFLENBQUNtSCxXQUFILENBQWUvQixJQUFmLEVBQXFCQyxJQUFyQixFQUEyQkcsT0FBTyxDQUFDakQsU0FBbkMsRUFBOENrRCxPQUFPLENBQUNsRCxTQUF0RCxFQUFpRW1ELE9BQWpFLENBQXRCO0FBQ0F6QixJQUFBQSxlQUFlLENBQUNpRCxhQUFELEVBQWdCTCxLQUFoQixDQUFmO0FBQ0E1QyxJQUFBQSxlQUFlLENBQUNpRCxhQUFELEVBQWdCO0FBQzdCcEUsTUFBQUEsQ0FBQyxFQUFFc0MsSUFBSSxDQUFDZ0MsSUFBTCxHQUFZTCxLQUFLLENBQUNqRSxDQURRO0FBRTdCQyxNQUFBQSxDQUFDLEVBQUVnRSxLQUFLLENBQUNoRSxDQUZvQjtBQUc3QkMsTUFBQUEsS0FBSyxFQUFFK0QsS0FBSyxDQUFDL0QsS0FIZ0I7QUFJN0JDLE1BQUFBLE1BQU0sRUFBRThELEtBQUssQ0FBQzlEO0FBSmUsS0FBaEIsQ0FBZjtBQU1BK0QsSUFBQUEsTUFBTSxDQUFDRSxhQUFQLEdBQXVCLE1BQU1sSCxFQUFFLENBQUNxSCxhQUFILENBQWlCLE1BQWpCLEVBQXlCSCxhQUF6QixDQUE3QjtBQUNEOztBQUNELFNBQU9GLE1BQVA7QUFDRDs7QUFzQ0QsZUFBZU0sbUJBQWYsQ0FBb0MzQyxRQUFwQyxFQUE4Q0MsUUFBOUMsRUFBd0RDLE9BQU8sR0FBRyxFQUFsRSxFQUFzRTtBQUNwRSxRQUFNL0MsVUFBVSxFQUFoQjtBQUVBLFFBQU07QUFDSnlGLElBQUFBLE1BQU0sR0FBRy9HLHVCQURMO0FBRUp1RSxJQUFBQSxTQUFTLEdBQUc7QUFGUixNQUdGRixPQUhKO0FBSUEsTUFBSSxDQUFDMkMsUUFBRCxFQUFXQyxTQUFYLElBQXdCLE1BQU0xRyxrQkFBRXVFLEdBQUYsQ0FBTSxDQUN0Q3RGLEVBQUUsQ0FBQ3VGLGFBQUgsQ0FBaUJaLFFBQWpCLENBRHNDLEVBRXRDM0UsRUFBRSxDQUFDdUYsYUFBSCxDQUFpQlgsUUFBakIsQ0FGc0MsQ0FBTixDQUFsQzs7QUFJQSxNQUFJNEMsUUFBUSxDQUFDRSxJQUFULEtBQWtCRCxTQUFTLENBQUNDLElBQTVCLElBQW9DRixRQUFRLENBQUNKLElBQVQsS0FBa0JLLFNBQVMsQ0FBQ0wsSUFBcEUsRUFBMEU7QUFDeEUsVUFBTSxJQUFJeEcsS0FBSixDQUFVLGdFQUNBLGlDQURWLENBQU47QUFFRDs7QUFDRCxHQUFDNEcsUUFBRCxFQUFXQyxTQUFYLElBQXdCLE1BQU0xRyxrQkFBRXVFLEdBQUYsQ0FBTSxDQUNsQ2tDLFFBQVEsQ0FBQ0csY0FBVCxDQUF3QjNILEVBQUUsQ0FBQzRILE9BQTNCLENBRGtDLEVBRWxDSCxTQUFTLENBQUNFLGNBQVYsQ0FBeUIzSCxFQUFFLENBQUM0SCxPQUE1QixDQUZrQyxDQUFOLENBQTlCO0FBS0EsTUFBSUMsT0FBSjs7QUFDQSxNQUFJO0FBQ0ZBLElBQUFBLE9BQU8sR0FBRyxNQUFNSixTQUFTLENBQUNLLGtCQUFWLENBQTZCTixRQUE3QixFQUF1Qy9HLGdCQUFnQixDQUFDOEcsTUFBRCxDQUF2RCxDQUFoQjtBQUNELEdBRkQsQ0FFRSxPQUFPNUIsQ0FBUCxFQUFVO0FBQ1YsVUFBTSxJQUFJL0UsS0FBSixDQUFXLDBFQUF5RStFLENBQUMsQ0FBQ3hELE9BQVEsRUFBOUYsQ0FBTjtBQUNEOztBQUNELFFBQU00RixNQUFNLEdBQUcsTUFBTUYsT0FBTyxDQUFDRyxjQUFSLEVBQXJCO0FBQ0EsUUFBTWhCLE1BQU0sR0FBRztBQUNiaUIsSUFBQUEsS0FBSyxFQUFFRixNQUFNLENBQUNHO0FBREQsR0FBZjs7QUFHQSxNQUFJbkQsU0FBSixFQUFlO0FBQ2IsVUFBTW9ELFNBQVMsR0FBRyxJQUFJbkksRUFBRSxDQUFDb0ksR0FBUCxDQUFXWixRQUFRLENBQUNFLElBQXBCLEVBQTBCRixRQUFRLENBQUNKLElBQVQsR0FBZ0IsQ0FBMUMsRUFBNkNwSCxFQUFFLENBQUM0SCxPQUFoRCxDQUFsQjtBQUNBLFVBQU03RyxrQkFBRXVFLEdBQUYsQ0FBTSxDQUNWbUMsU0FBUyxDQUFDWSxXQUFWLENBQ0VGLFNBQVMsQ0FBQ0csU0FBVixDQUFvQixJQUFJdEksRUFBRSxDQUFDd0UsSUFBUCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCaUQsU0FBUyxDQUFDTCxJQUE1QixFQUFrQ0ssU0FBUyxDQUFDQyxJQUE1QyxDQUFwQixDQURGLENBRFUsRUFHVkYsUUFBUSxDQUFDYSxXQUFULENBQ0VGLFNBQVMsQ0FBQ0csU0FBVixDQUFvQixJQUFJdEksRUFBRSxDQUFDd0UsSUFBUCxDQUFZaUQsU0FBUyxDQUFDTCxJQUF0QixFQUE0QixDQUE1QixFQUErQkksUUFBUSxDQUFDSixJQUF4QyxFQUE4Q0ksUUFBUSxDQUFDRSxJQUF2RCxDQUFwQixDQURGLENBSFUsQ0FBTixDQUFOO0FBTUEsUUFBSWEsSUFBSSxHQUFHZCxTQUFTLENBQUNlLE9BQVYsQ0FBa0JoQixRQUFsQixDQUFYO0FBQ0FlLElBQUFBLElBQUksR0FBRyxNQUFNQSxJQUFJLENBQUNFLGFBQUwsQ0FBbUJ6SSxFQUFFLENBQUMwSSxjQUF0QixDQUFiO0FBQ0EsUUFBSUMsUUFBUSxHQUFHLEVBQWY7O0FBQ0EsUUFBSTtBQUNGSixNQUFBQSxJQUFJLEdBQUcsTUFBTUEsSUFBSSxDQUFDSyxjQUFMLENBQW9CLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCNUksRUFBRSxDQUFDNkksYUFBSCxHQUFtQjdJLEVBQUUsQ0FBQzhJLFdBQXBELENBQWI7QUFDQUgsTUFBQUEsUUFBUSxHQUFHLE1BQU1KLElBQUksQ0FBQ1EsaUJBQUwsQ0FBdUIvSSxFQUFFLENBQUNnSixhQUExQixFQUF5Q2hKLEVBQUUsQ0FBQ2lKLG1CQUE1QyxDQUFqQjtBQUNELEtBSEQsQ0FHRSxPQUFPQyxHQUFQLEVBQVksQ0FFYjs7QUFDRCxTQUFLLE1BQU1DLE9BQVgsSUFBc0JSLFFBQXRCLEVBQWdDO0FBQzlCLFlBQU1TLFlBQVksR0FBR0QsT0FBTyxDQUFDQyxZQUFSLEVBQXJCO0FBQ0FuRixNQUFBQSxlQUFlLENBQUNrRSxTQUFELEVBQVlpQixZQUFaLENBQWY7QUFDQW5GLE1BQUFBLGVBQWUsQ0FBQ2tFLFNBQUQsRUFBWTtBQUN6QnJGLFFBQUFBLENBQUMsRUFBRTJFLFNBQVMsQ0FBQ0wsSUFBVixHQUFpQmdDLFlBQVksQ0FBQ3RHLENBRFI7QUFFekJDLFFBQUFBLENBQUMsRUFBRXFHLFlBQVksQ0FBQ3JHLENBRlM7QUFHekJDLFFBQUFBLEtBQUssRUFBRW9HLFlBQVksQ0FBQ3BHLEtBSEs7QUFJekJDLFFBQUFBLE1BQU0sRUFBRW1HLFlBQVksQ0FBQ25HO0FBSkksT0FBWixDQUFmO0FBTUQ7O0FBQ0QrRCxJQUFBQSxNQUFNLENBQUNFLGFBQVAsR0FBdUIsTUFBTWxILEVBQUUsQ0FBQ3FILGFBQUgsQ0FBaUIsTUFBakIsRUFBeUJjLFNBQXpCLENBQTdCO0FBQ0Q7O0FBQ0QsU0FBT25CLE1BQVA7QUFDRDs7QUFnREQsZUFBZXFDLGtCQUFmLENBQW1DQyxXQUFuQyxFQUFnREMsY0FBaEQsRUFBZ0UxRSxPQUFPLEdBQUcsRUFBMUUsRUFBOEU7QUFDNUUsUUFBTS9DLFVBQVUsRUFBaEI7QUFFQSxRQUFNO0FBQ0ppRCxJQUFBQSxTQUFTLEdBQUcsS0FEUjtBQUVKeUUsSUFBQUEsU0FBUyxHQUFHckosdUJBRlI7QUFHSnNKLElBQUFBLFFBQVEsR0FBRyxLQUhQO0FBSUpDLElBQUFBLHVCQUF1QixHQUFHdEoseUJBSnRCO0FBS0ptSCxJQUFBQSxNQUFNLEdBQUcvRztBQUxMLE1BTUZxRSxPQU5KO0FBUUEsUUFBTSxDQUFDOEUsT0FBRCxFQUFVQyxVQUFWLElBQXdCLE1BQU03SSxrQkFBRXVFLEdBQUYsQ0FBTSxDQUN4Q3RGLEVBQUUsQ0FBQ3VGLGFBQUgsQ0FBaUIrRCxXQUFqQixDQUR3QyxFQUV4Q3RKLEVBQUUsQ0FBQ3VGLGFBQUgsQ0FBaUJnRSxjQUFqQixDQUZ3QyxDQUFOLENBQXBDO0FBSUEsUUFBTU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBSTNDLGFBQWEsR0FBRyxJQUFwQjs7QUFFQSxNQUFJO0FBQ0YsVUFBTVcsT0FBTyxHQUFHLE1BQU04QixPQUFPLENBQUM3QixrQkFBUixDQUEyQjhCLFVBQTNCLEVBQXVDbkosZ0JBQWdCLENBQUM4RyxNQUFELENBQXZELENBQXRCO0FBQ0EsVUFBTVEsTUFBTSxHQUFHLE1BQU1GLE9BQU8sQ0FBQ0csY0FBUixFQUFyQjs7QUFFQSxRQUFJeUIsUUFBSixFQUFjO0FBQ1osWUFBTUssbUJBQW1CLEdBQUdqQyxPQUFPLENBQUMyQixTQUFSLENBQWtCQSxTQUFsQixFQUE2QixDQUE3QixFQUFnQ3hKLEVBQUUsQ0FBQzZJLGFBQW5DLEVBQ3pCa0IsU0FEeUIsQ0FDZi9KLEVBQUUsQ0FBQ2dLLEtBRFksRUFFekJDLFdBRnlCLEVBQTVCO0FBR0EsWUFBTXZFLE9BQU8sR0FBR3dFLGlCQUFpQixDQUFDSixtQkFBRCxFQUFzQkosdUJBQXRCLENBQWpDOztBQUVBLFdBQUssTUFBTTtBQUFDNUcsUUFBQUEsQ0FBRDtBQUFJQyxRQUFBQTtBQUFKLE9BQVgsSUFBcUIyQyxPQUFyQixFQUE4QjtBQUM1Qm1FLFFBQUFBLE9BQU8sQ0FBQ00sSUFBUixDQUFhO0FBQ1hsQyxVQUFBQSxLQUFLLEVBQUVKLE9BQU8sQ0FBQ3VDLEVBQVIsQ0FBV3JILENBQVgsRUFBY0QsQ0FBZCxDQURJO0FBRVh1SCxVQUFBQSxJQUFJLEVBQUU7QUFDSnZILFlBQUFBLENBREk7QUFDREMsWUFBQUEsQ0FEQztBQUVKQyxZQUFBQSxLQUFLLEVBQUU0RyxVQUFVLENBQUN4QyxJQUZkO0FBR0puRSxZQUFBQSxNQUFNLEVBQUUyRyxVQUFVLENBQUNsQztBQUhmO0FBRkssU0FBYjtBQVFEO0FBQ0YsS0FoQkQsTUFnQk8sSUFBSUssTUFBTSxDQUFDRyxNQUFQLElBQWlCc0IsU0FBckIsRUFBZ0M7QUFDckMsWUFBTTtBQUFDMUcsUUFBQUEsQ0FBRDtBQUFJQyxRQUFBQTtBQUFKLFVBQVN3RSxNQUFNLENBQUM1RyxRQUFQLENBQWdCLFFBQWhCLElBQTRCb0gsTUFBTSxDQUFDdUMsTUFBbkMsR0FBNEN2QyxNQUFNLENBQUN3QyxNQUFsRTtBQUNBVixNQUFBQSxPQUFPLENBQUNNLElBQVIsQ0FBYTtBQUNYbEMsUUFBQUEsS0FBSyxFQUFFRixNQUFNLENBQUNHLE1BREg7QUFFWG1DLFFBQUFBLElBQUksRUFBRTtBQUNKdkgsVUFBQUEsQ0FESTtBQUNEQyxVQUFBQSxDQURDO0FBRUpDLFVBQUFBLEtBQUssRUFBRTRHLFVBQVUsQ0FBQ3hDLElBRmQ7QUFHSm5FLFVBQUFBLE1BQU0sRUFBRTJHLFVBQVUsQ0FBQ2xDO0FBSGY7QUFGSyxPQUFiO0FBUUQ7O0FBRUQsUUFBSXhHLGdCQUFFc0osT0FBRixDQUFVWCxPQUFWLENBQUosRUFBd0I7QUFFdEIsWUFBTSxJQUFJakosS0FBSixDQUFXLG9CQUFtQjRJLFNBQVUsd0JBQTlCLEdBQ0MsYUFBWXpCLE1BQU0sQ0FBQ0csTUFBTyxFQURyQyxDQUFOO0FBRUQ7QUFDRixHQXJDRCxDQXFDRSxPQUFPdkMsQ0FBUCxFQUFVO0FBRVYsVUFBTSxJQUFJL0UsS0FBSixDQUFXLHNFQUFELEdBQ2IsbUJBQWtCK0UsQ0FBQyxDQUFDeEQsT0FBUSxFQUR6QixDQUFOO0FBRUQ7O0FBRUQsTUFBSTRDLFNBQUosRUFBZTtBQUNiLFVBQU0wRixvQkFBb0IsR0FBR2QsT0FBTyxDQUFDZSxJQUFSLEVBQTdCOztBQUVBLFNBQUssTUFBTTFELE1BQVgsSUFBcUI2QyxPQUFyQixFQUE4QjtBQUM1QixZQUFNYyxzQkFBc0IsR0FBR2hCLE9BQU8sQ0FBQ2UsSUFBUixFQUEvQjtBQUVBekcsTUFBQUEsZUFBZSxDQUFDMEcsc0JBQUQsRUFBeUIzRCxNQUFNLENBQUNxRCxJQUFoQyxDQUFmO0FBQ0FwRyxNQUFBQSxlQUFlLENBQUN3RyxvQkFBRCxFQUF1QnpELE1BQU0sQ0FBQ3FELElBQTlCLENBQWY7QUFDQXJELE1BQUFBLE1BQU0sQ0FBQ0UsYUFBUCxHQUF1QixNQUFNbEgsRUFBRSxDQUFDcUgsYUFBSCxDQUFpQixNQUFqQixFQUF5QnNELHNCQUF6QixDQUE3QjtBQUNEOztBQUNEekQsSUFBQUEsYUFBYSxHQUFHLE1BQU1sSCxFQUFFLENBQUNxSCxhQUFILENBQWlCLE1BQWpCLEVBQXlCb0Qsb0JBQXpCLENBQXRCO0FBQ0Q7O0FBRUQsU0FBTztBQUNMSixJQUFBQSxJQUFJLEVBQUVSLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV1EsSUFEWjtBQUVMcEMsSUFBQUEsS0FBSyxFQUFFNEIsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXNUIsS0FGYjtBQUdMZixJQUFBQSxhQUhLO0FBSUx1QyxJQUFBQSxRQUFRLEVBQUVJO0FBSkwsR0FBUDtBQU1EOztBQVVELFNBQVNLLGlCQUFULENBQTRCSixtQkFBNUIsRUFBaURKLHVCQUFqRCxFQUEwRTtBQUN4RSxTQUFPSSxtQkFBbUIsQ0FBQ2MsTUFBcEIsQ0FBMkIsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEtBQWtCO0FBQ2xELFFBQUksQ0FBQ0QsR0FBRyxDQUFDRSxJQUFKLENBQVVoRixLQUFELElBQVdDLFFBQVEsQ0FBQ0QsS0FBRCxFQUFRK0UsT0FBUixDQUFSLElBQTRCcEIsdUJBQWhELENBQUwsRUFBK0U7QUFDN0VtQixNQUFBQSxHQUFHLENBQUNWLElBQUosQ0FBU1csT0FBVDtBQUNEOztBQUNELFdBQU9ELEdBQVA7QUFDRCxHQUxNLEVBS0osRUFMSSxDQUFQO0FBTUQ7O0FBU0QsU0FBUzdFLFFBQVQsQ0FBbUJnRixNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUM7QUFDakMsUUFBTUMsRUFBRSxHQUFHN0gsSUFBSSxDQUFDOEgsR0FBTCxDQUFVSCxNQUFNLENBQUNsSSxDQUFQLEdBQVdtSSxNQUFNLENBQUNuSSxDQUE1QixFQUFnQyxDQUFoQyxDQUFYO0FBQ0EsUUFBTXNJLEVBQUUsR0FBRy9ILElBQUksQ0FBQzhILEdBQUwsQ0FBVUgsTUFBTSxDQUFDakksQ0FBUCxHQUFXa0ksTUFBTSxDQUFDbEksQ0FBNUIsRUFBZ0MsQ0FBaEMsQ0FBWDtBQUNBLFNBQU9NLElBQUksQ0FBQ0MsSUFBTCxDQUFVNEgsRUFBRSxHQUFHRSxFQUFmLENBQVA7QUFDRDs7QUFTRCxlQUFlQyxlQUFmLENBQWdDQyxXQUFoQyxFQUE2Q2pCLElBQTdDLEVBQW1EO0FBQ2pELFFBQU1rQixLQUFLLEdBQUcsTUFBTUMsYUFBYSxDQUFDRixXQUFELENBQWpDO0FBQ0FHLEVBQUFBLFNBQVMsQ0FBQ0YsS0FBRCxFQUFRbEIsSUFBUixDQUFUO0FBQ0EsU0FBTyxNQUFNcUIsYUFBYSxDQUFDSCxLQUFELENBQTFCO0FBQ0Q7O0FBUUQsZUFBZUMsYUFBZixDQUE4QkYsV0FBOUIsRUFBMkM7QUFDekMsUUFBTUssV0FBVyxHQUFHdEssZUFBT0MsSUFBUCxDQUFZZ0ssV0FBWixFQUF5QixRQUF6QixDQUFwQjs7QUFDQSxTQUFPLE1BQU0sSUFBSXZLLGlCQUFKLENBQU0sQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDLFVBQU1zSyxLQUFLLEdBQUcsSUFBSUssVUFBSixDQUFRO0FBQUNDLE1BQUFBLFVBQVUsRUFBRTNMO0FBQWIsS0FBUixDQUFkO0FBQ0FxTCxJQUFBQSxLQUFLLENBQUNPLEtBQU4sQ0FBWUgsV0FBWixFQUF5QixDQUFDcEssR0FBRCxFQUFNZ0ssS0FBTixLQUFnQjtBQUN2QyxVQUFJaEssR0FBSixFQUFTO0FBQ1AsZUFBT04sTUFBTSxDQUFDTSxHQUFELENBQWI7QUFDRDs7QUFDRFAsTUFBQUEsT0FBTyxDQUFDdUssS0FBRCxDQUFQO0FBQ0QsS0FMRDtBQU1ELEdBUlksQ0FBYjtBQVNEOztBQVFELGVBQWVHLGFBQWYsQ0FBOEJILEtBQTlCLEVBQXFDO0FBQ25DLFNBQU8sTUFBTSxJQUFJeEssaUJBQUosQ0FBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMsVUFBTThLLE1BQU0sR0FBRyxFQUFmO0FBQ0FSLElBQUFBLEtBQUssQ0FBQ1MsSUFBTixHQUNDQyxFQURELENBQ0ksTUFESixFQUNhQyxLQUFELElBQVdILE1BQU0sQ0FBQzVCLElBQVAsQ0FBWStCLEtBQVosQ0FEdkIsRUFDMkNELEVBRDNDLENBQzhDLEtBRDlDLEVBQ3FELE1BQU07QUFDekRqTCxNQUFBQSxPQUFPLENBQUNLLGVBQU84SyxNQUFQLENBQWNKLE1BQWQsRUFBc0JLLFFBQXRCLENBQStCLFFBQS9CLENBQUQsQ0FBUDtBQUNELEtBSEQsRUFJQ0gsRUFKRCxDQUlJLE9BSkosRUFJYzFLLEdBQUQsSUFBUztBQUNwQk4sTUFBQUEsTUFBTSxDQUFDTSxHQUFELENBQU47QUFDRCxLQU5EO0FBT0QsR0FUWSxDQUFiO0FBVUQ7O0FBUUQsU0FBU2tLLFNBQVQsQ0FBb0JGLEtBQXBCLEVBQTJCbEIsSUFBM0IsRUFBaUM7QUFDL0IsUUFBTWdDLFNBQVMsR0FBRztBQUFDckosSUFBQUEsS0FBSyxFQUFFdUksS0FBSyxDQUFDdkksS0FBZDtBQUFxQkMsSUFBQUEsTUFBTSxFQUFFc0ksS0FBSyxDQUFDdEk7QUFBbkMsR0FBbEI7QUFDQSxRQUFNcUosU0FBUyxHQUFHQyxtQkFBbUIsQ0FBQ2xDLElBQUQsRUFBT2dDLFNBQVAsQ0FBckM7O0FBQ0EsTUFBSUMsU0FBUyxDQUFDdEosS0FBVixHQUFrQnFILElBQUksQ0FBQ3JILEtBQXZCLElBQWdDc0osU0FBUyxDQUFDckosTUFBVixHQUFtQm9ILElBQUksQ0FBQ3BILE1BQTVELEVBQW9FO0FBQ2xFLFVBQU0sSUFBSXJDLEtBQUosQ0FBVyxlQUFjc0UsSUFBSSxDQUFDQyxTQUFMLENBQWVrRixJQUFmLENBQXFCLFNBQVFuRixJQUFJLENBQUNDLFNBQUwsQ0FBZWtILFNBQWYsQ0FBMEIscUVBQWhGLENBQU47QUFDRDs7QUFFRCxRQUFNRyxrQkFBa0IsR0FBR0YsU0FBUyxDQUFDRyxHQUFyQztBQUNBLFFBQU1DLGlCQUFpQixHQUFHSixTQUFTLENBQUNHLEdBQVYsR0FBZ0JILFNBQVMsQ0FBQ3JKLE1BQXBEO0FBRUEsUUFBTTBKLG9CQUFvQixHQUFHTCxTQUFTLENBQUNNLElBQXZDO0FBQ0EsUUFBTUMsbUJBQW1CLEdBQUdQLFNBQVMsQ0FBQ00sSUFBVixHQUFpQk4sU0FBUyxDQUFDdEosS0FBdkQ7QUFFQSxRQUFNOEosWUFBWSxHQUFHLEVBQXJCOztBQUNBLE9BQUssSUFBSS9KLENBQUMsR0FBR3lKLGtCQUFiLEVBQWlDekosQ0FBQyxHQUFHMkosaUJBQXJDLEVBQXdEM0osQ0FBQyxFQUF6RCxFQUE2RDtBQUMzRCxTQUFLLElBQUlELENBQUMsR0FBRzZKLG9CQUFiLEVBQW1DN0osQ0FBQyxHQUFHK0osbUJBQXZDLEVBQTREL0osQ0FBQyxFQUE3RCxFQUFpRTtBQUMvRCxZQUFNaUssd0JBQXdCLEdBQUlWLFNBQVMsQ0FBQ3JKLEtBQVYsR0FBa0JELENBQWxCLEdBQXNCRCxDQUF2QixJQUE2QixDQUE5RDs7QUFDQSxXQUFLLElBQUlrSyxPQUFPLEdBQUcsQ0FBbkIsRUFBc0JBLE9BQU8sR0FBRy9NLG9CQUFoQyxFQUFzRCtNLE9BQU8sRUFBN0QsRUFBaUU7QUFDL0RGLFFBQUFBLFlBQVksQ0FBQzNDLElBQWIsQ0FBa0JvQixLQUFLLENBQUN6SyxJQUFOLENBQVdpTSx3QkFBd0IsR0FBR0MsT0FBdEMsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUR6QixFQUFBQSxLQUFLLENBQUN6SyxJQUFOLEdBQWFPLGVBQU9DLElBQVAsQ0FBWXdMLFlBQVosQ0FBYjtBQUNBdkIsRUFBQUEsS0FBSyxDQUFDdkksS0FBTixHQUFjc0osU0FBUyxDQUFDdEosS0FBeEI7QUFDQXVJLEVBQUFBLEtBQUssQ0FBQ3RJLE1BQU4sR0FBZXFKLFNBQVMsQ0FBQ3JKLE1BQXpCO0FBQ0EsU0FBT3NJLEtBQVA7QUFDRDs7QUFFRCxTQUFTZ0IsbUJBQVQsQ0FBOEJsQyxJQUE5QixFQUFvQzRDLFNBQXBDLEVBQStDO0FBQzdDLFFBQU1MLElBQUksR0FBR3ZDLElBQUksQ0FBQ3VDLElBQUwsSUFBYUssU0FBUyxDQUFDakssS0FBdkIsR0FBK0JpSyxTQUFTLENBQUNqSyxLQUF6QyxHQUFpRHFILElBQUksQ0FBQ3VDLElBQW5FO0FBQ0EsUUFBTUgsR0FBRyxHQUFHcEMsSUFBSSxDQUFDb0MsR0FBTCxJQUFZUSxTQUFTLENBQUNoSyxNQUF0QixHQUErQmdLLFNBQVMsQ0FBQ2hLLE1BQXpDLEdBQWtEb0gsSUFBSSxDQUFDb0MsR0FBbkU7QUFDQSxRQUFNekosS0FBSyxHQUFHaUssU0FBUyxDQUFDakssS0FBVixJQUFvQjRKLElBQUksR0FBR3ZDLElBQUksQ0FBQ3JILEtBQWhDLEdBQXlDcUgsSUFBSSxDQUFDckgsS0FBOUMsR0FBdURpSyxTQUFTLENBQUNqSyxLQUFWLEdBQWtCNEosSUFBdkY7QUFDQSxRQUFNM0osTUFBTSxHQUFHZ0ssU0FBUyxDQUFDaEssTUFBVixJQUFxQndKLEdBQUcsR0FBR3BDLElBQUksQ0FBQ3BILE1BQWhDLEdBQTBDb0gsSUFBSSxDQUFDcEgsTUFBL0MsR0FBeURnSyxTQUFTLENBQUNoSyxNQUFWLEdBQW1Cd0osR0FBM0Y7QUFDQSxTQUFPO0FBQUNHLElBQUFBLElBQUQ7QUFBT0gsSUFBQUEsR0FBUDtBQUFZekosSUFBQUEsS0FBWjtBQUFtQkMsSUFBQUE7QUFBbkIsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBKaW1wIGZyb20gJ2ppbXAnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IFBORyB9IGZyb20gJ3BuZ2pzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGhhc1ZhbHVlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgcmVxdWlyZVBhY2thZ2UgfSBmcm9tICcuL25vZGUnO1xuXG5cbmNvbnN0IHsgTUlNRV9KUEVHLCBNSU1FX1BORywgTUlNRV9CTVAgfSA9IEppbXA7XG5sZXQgY3YgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZ2lvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgLSBUaGUgb2Zmc2V0IGZyb20gdGhlIGxlZnQgc2lkZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgdG9wXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIGJvdHRvbSByaWdodCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0XG4gKi9cblxuY29uc3QgQllURVNfSU5fUElYRUxfQkxPQ0sgPSA0O1xuY29uc3QgU0NBTkxJTkVfRklMVEVSX01FVEhPRCA9IDQ7XG5jb25zdCBERUZBVUxUX01BVENIX1RIUkVTSE9MRCA9IDAuNTtcbmNvbnN0IE1BVENIX05FSUdIQk9VUl9USFJFU0hPTEQgPSAxMDtcblxuY29uc3QgQVZBSUxBQkxFX0RFVEVDVE9SUyA9IFtcbiAgJ0FLQVpFJyxcbiAgJ0FHQVNUJyxcbiAgJ0JSSVNLJyxcbiAgJ0ZBU1QnLFxuICAnR0ZUVCcsXG4gICdLQVpFJyxcbiAgJ01TRVInLFxuICAnU0lGVCcsXG4gICdPUkInLFxuXTtcblxuY29uc3QgQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUyA9IFtcbiAgJ0ZsYW5uQmFzZWQnLFxuICAnQnJ1dGVGb3JjZScsXG4gICdCcnV0ZUZvcmNlTDEnLFxuICAnQnJ1dGVGb3JjZUhhbW1pbmcnLFxuICAnQnJ1dGVGb3JjZUhhbW1pbmdMdXQnLFxuICAnQnJ1dGVGb3JjZVNMMicsXG5dO1xuXG5jb25zdCBNQVRDSElOR19NRVRIT0RTID0gW1xuICAnVE1fQ0NPRUZGJyxcbiAgJ1RNX0NDT0VGRl9OT1JNRUQnLFxuICAnVE1fQ0NPUlInLFxuICAnVE1fQ0NPUlJfTk9STUVEJyxcbiAgJ1RNX1NRRElGRicsXG4gICdUTV9TUURJRkZfTk9STUVEJyxcbl07XG5jb25zdCBERUZBVUxUX01BVENISU5HX01FVEhPRCA9ICdUTV9DQ09FRkZfTk9STUVEJztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIG1hdGNoaW5nIG1ldGhvZCBuYW1lIHRvIHRoZSBhY3R1YWxcbiAqIGNvbnN0YW50IHZhbHVlIGZyb20gT3BlbkNWIGxpYnJhcnlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmUgb2Ygc3VwcG9ydGVkIG1ldGhvZCBuYW1lc1xuICogKHNlZSBNQVRDSElOR19NRVRIT0RTIGFycmF5IGFib3ZlKVxuICogQHJldHVybnMge251bWJlcn0gVGhlIG1ldGhvZCB2YWx1ZVxuICogQHRocm93cyB7RXJyb3J9IGlmIGFuIHVuc3VwcG9ydGVkIG1ldGhvZCBuYW1lIGlzIGdpdmVuXG4gKi9cbmZ1bmN0aW9uIHRvTWF0Y2hpbmdNZXRob2QgKG5hbWUpIHtcbiAgaWYgKCFNQVRDSElOR19NRVRIT0RTLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF0Y2hpbmcgbWV0aG9kICcke25hbWV9JyBpcyB1bmtub3duLiBgICtcbiAgICAgIGBPbmx5IHRoZSBmb2xsb3dpbmcgbWF0Y2hpbmcgbWV0aG9kcyBhcmUgc3VwcG9ydGVkOiAke01BVENISU5HX01FVEhPRFN9YCk7XG4gIH1cbiAgcmV0dXJuIGN2W25hbWVdO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IGEgSmltcCBpbWFnZSBvYmplY3QgZnJvbSBidWZmZXIgb3IgYmFzZTY0IGRhdGEuIEppbXBcbiAqIGlzIGEgZ3JlYXQgbGlicmFyeSBob3dldmVyIGl0IGRvZXMgSU8gaW4gdGhlIGNvbnN0cnVjdG9yIHNvIGl0J3Mgbm90XG4gKiBjb252ZW5pZW50IGZvciBvdXIgYXN5bmMvYXdhaXQgbW9kZWwuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBkYXRhIC0gYmluYXJ5IGltYWdlIGJ1ZmZlciBvciBiYXNlNjQtZW5jb2RlZCBpbWFnZVxuICogc3RyaW5nXG4gKiBAcmV0dXJucyB7SmltcH0gLSB0aGUgamltcCBpbWFnZSBvYmplY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SmltcEltYWdlIChkYXRhKSB7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGRhdGEpICYmICFfLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTXVzdCBpbml0aWFsaXplIGppbXAgb2JqZWN0IHdpdGggc3RyaW5nIG9yIGJ1ZmZlcicpKTtcbiAgICB9XG4gICAgLy8gaWYgZGF0YSBpcyBhIHN0cmluZywgYXNzdW1lIGl0IGlzIGEgYmFzZTY0LWVuY29kZWQgaW1hZ2VcbiAgICBpZiAoXy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICB9XG4gICAgbmV3IEppbXAoZGF0YSwgKGVyciwgaW1nT2JqKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW1nT2JqKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGppbXAgaW1hZ2UgZnJvbSB0aGF0IGRhdGEnKSk7XG4gICAgICB9XG4gICAgICBpbWdPYmouX2dldEJ1ZmZlciA9IGltZ09iai5nZXRCdWZmZXIuYmluZChpbWdPYmopO1xuICAgICAgaW1nT2JqLmdldEJ1ZmZlciA9IEIucHJvbWlzaWZ5KGltZ09iai5fZ2V0QnVmZmVyLCB7Y29udGV4dDogaW1nT2JqfSk7XG4gICAgICByZXNvbHZlKGltZ09iaik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuY3Y0bm9kZWpzIG1vZHVsZSBpcyBub3QgaW5zdGFsbGVkIG9yIGNhbm5vdCBiZSBsb2FkZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdE9wZW5DViAoKSB7XG4gIGlmIChjdikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgSW5pdGlhbGl6aW5nIE9wZW5DVmApO1xuICBmb3IgKGNvbnN0IHBrZ05hbWUgb2YgWydAdTQvb3BlbmN2NG5vZGVqcycsICdvcGVuY3Y0bm9kZWpzJ10pIHtcbiAgICB0cnkge1xuICAgICAgY3YgPSBhd2FpdCByZXF1aXJlUGFja2FnZShwa2dOYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gbG9hZCAnJHtwa2dOYW1lfSc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjdikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJ0B1NC9vcGVuY3Y0bm9kZWpzJyBtb2R1bGUgaXMgcmVxdWlyZWQgdG8gdXNlIE9wZW5DViBmZWF0dXJlcy4gYCArXG4gICAgICBgUGxlYXNlIGluc3RhbGwgaXQgZmlyc3QgYW5kIHJlc3RhcnQgQXBwaXVtLiBgICtcbiAgICAgIGBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtLXBsdWdpbnMvcHVsbC83MyNpc3N1ZWNvbW1lbnQtMTAxMzY4MzA3NCBhbmQgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL1VyaWVsQ2gvb3BlbmN2NG5vZGVqcyNmb3JrLWNoYW5nZXMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHRvcGljLmApO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWF0Y2hDb21wdXRhdGlvblJlc3VsdFxuICogQHByb3BlcnR5IHtjdi5EZXNjcmlwdG9yTWF0Y2h9IGRlc2NpcHRvciAtIE9wZW5DViBtYXRjaCBkZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge0FycmF5PGN2LktleVBvaW50Pn0ga2V5UG9pbnRzIC0gVGhlIGFycmF5IG9mIGtleSBwb2ludHNcbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW4gT3BlbkNWIG1hdGNoIGRlc2NyaXB0b3Igb2YgYW4gaW1hZ2UsIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiBmb3IgYnJ1dGUtZm9yY2UgbWF0Y2hpbmcuXG4gKiBSZWFkIGh0dHBzOi8vZG9jcy5vcGVuY3Yub3JnLzMuMC1iZXRhL2RvYy9weV90dXRvcmlhbHMvcHlfZmVhdHVyZTJkL3B5X21hdGNoZXIvcHlfbWF0Y2hlci5odG1sXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7Y3YuTWF0fSBpbWcgSW1hZ2UgZGF0YVxuICogQHBhcmFtIHtjdi5GZWF0dXJlRGV0ZWN0b3J9IGRldGVjdG9yIE9wZW5DViBmZWF0dXJlIGRldGVjdG9yIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge01hdGNoQ29tcHV0YXRpb25SZXN1bHR9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdEFuZENvbXB1dGUgKGltZywgZGV0ZWN0b3IpIHtcbiAgY29uc3Qga2V5UG9pbnRzID0gYXdhaXQgZGV0ZWN0b3IuZGV0ZWN0QXN5bmMoaW1nKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IGF3YWl0IGRldGVjdG9yLmNvbXB1dGVBc3luYyhpbWcsIGtleVBvaW50cyk7XG4gIHJldHVybiB7XG4gICAga2V5UG9pbnRzLFxuICAgIGRlc2NyaXB0b3JcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVkIHRoZSBib3VuZGluZyByZWN0IGNvb3JkaW5hdGVzIGZvciB0aGUgYXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG1hdGNoZWRQb2ludHMgQXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzXG4gKiBAcmV0dXJucyB7UmVjdH0gVGhlIG1hdGNoaW5nIGJvdW5kaW5nIHJlY3Qgb3IgYSB6ZXJvIHJlY3QgaWYgbm8gbWF0Y2hcbiAqIGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0Y2hlZFJlY3QgKG1hdGNoZWRQb2ludHMpIHtcbiAgaWYgKG1hdGNoZWRQb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UgPSBtYXRjaGVkUG9pbnRzXG4gICAgLm1hcCgocG9pbnQpID0+IFtNYXRoLnNxcnQocG9pbnQueCAqIHBvaW50LnggKyBwb2ludC55ICogcG9pbnQueSksIHBvaW50XSlcbiAgICAuc29ydCgocGFpcjEsIHBhaXIyKSA9PiBwYWlyMVswXSA+PSBwYWlyMlswXSlcbiAgICAubWFwKChwYWlyKSA9PiBwYWlyWzFdKTtcbiAgY29uc3QgZmlyc3RQb2ludCA9IF8uaGVhZChwb2ludHNTb3J0ZWRCeURpc3RhbmNlKTtcbiAgY29uc3QgbGFzdFBvaW50ID0gXy5sYXN0KHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UpO1xuICBjb25zdCB0b3BMZWZ0UG9pbnQgPSB7XG4gICAgeDogZmlyc3RQb2ludC54IDw9IGxhc3RQb2ludC54ID8gZmlyc3RQb2ludC54IDogbGFzdFBvaW50LngsXG4gICAgeTogZmlyc3RQb2ludC55IDw9IGxhc3RQb2ludC55ID8gZmlyc3RQb2ludC55IDogbGFzdFBvaW50LnksXG4gIH07XG4gIGNvbnN0IGJvdHRvbVJpZ2h0UG9pbnQgPSB7XG4gICAgeDogZmlyc3RQb2ludC54ID49IGxhc3RQb2ludC54ID8gZmlyc3RQb2ludC54IDogbGFzdFBvaW50LngsXG4gICAgeTogZmlyc3RQb2ludC55ID49IGxhc3RQb2ludC55ID8gZmlyc3RQb2ludC55IDogbGFzdFBvaW50LnksXG4gIH07XG4gIHJldHVybiB7XG4gICAgeDogdG9wTGVmdFBvaW50LngsXG4gICAgeTogdG9wTGVmdFBvaW50LnksXG4gICAgd2lkdGg6IGJvdHRvbVJpZ2h0UG9pbnQueCAtIHRvcExlZnRQb2ludC54LFxuICAgIGhlaWdodDogYm90dG9tUmlnaHRQb2ludC55IC0gdG9wTGVmdFBvaW50LnlcbiAgfTtcbn1cblxuLyoqXG4gKiBEcmF3cyBhIHJlY3Rhbm5nbGUgb24gdGhlIGdpdmVuIGltYWdlIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7Y3YuTWF0fSBtYXQgVGhlIHNvdXJjZSBpbWFnZVxuICogQHBhcmFtIHtSZWN0fSByZWdpb24gVGhlIHJlZ2lvbiB0byBoaWdobGlnaHRcbiAqXG4gKiBAcmV0dXJucyB7Y3YuTWF0fSBUaGUgc2FtZSBpbWFnZSB3aXRoIHRoZSByZWN0YW5nbGUgb24gaXRcbiAqL1xuZnVuY3Rpb24gaGlnaGxpZ2h0UmVnaW9uIChtYXQsIHJlZ2lvbikge1xuICBpZiAocmVnaW9uLndpZHRoIDw9IDAgfHwgcmVnaW9uLmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGlnaGxpZ2h0IGluIHJlZFxuICBjb25zdCBjb2xvciA9IG5ldyBjdi5WZWMoMCwgMCwgMjU1KTtcbiAgY29uc3QgdGhpY2tuZXNzID0gMjtcbiAgbWF0LmRyYXdSZWN0YW5nbGUobmV3IGN2LlJlY3QocmVnaW9uLngsIHJlZ2lvbi55LCByZWdpb24ud2lkdGgsIHJlZ2lvbi5oZWlnaHQpLCBjb2xvciwgdGhpY2tuZXNzLCBjdi5MSU5FXzgpO1xuICByZXR1cm4gbWF0O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoaW5nT3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBkZXRlY3Rvck5hbWUgWydPUkInXSBPbmUgb2YgcG9zc2libGUgT3BlbkNWIGZlYXR1cmUgZGV0ZWN0b3IgbmFtZXNcbiAqIGZyb20gYEFWQUlMQUJMRV9ERVRFQ1RPUlNgIGFycmF5LlxuICogU29tZSBvZiB0aGVzZSBtZXRob2RzIChGQVNULCBBR0FTVCwgR0ZUVCwgRkFTVCwgU0lGVCBhbmQgTVNFUikgYXJlIG5vdCBhdmFpbGFibGVcbiAqIGluIHRoZSBkZWZhdWx0IE9wZW5DViBpbnN0YWxsYXRpb24gYW5kIGhhdmUgdG8gYmUgZW5hYmxlZCBtYW51YWxseSBiZWZvcmVcbiAqIGxpYnJhcnkgY29tcGlsYXRpb24uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1hdGNoRnVuYyBbJ0JydXRlRm9yY2UnXSBUaGUgbmFtZSBvZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24uXG4gKiBTaG91bGQgYmUgb25lIG9mIGBBVkFJTEFCTEVfTUFUQ0hJTkdfRlVOQ1RJT05TYCBhcnJheS5cbiAqIEBwcm9wZXJ0eSB7P251bWJlcnxGdW5jdGlvbn0gZ29vZE1hdGNoZXNGYWN0b3IgVGhlIG1heGltdW0gY291bnQgb2YgXCJnb29kXCIgbWF0Y2hlc1xuICogKGUuIGcuIHdpdGggbWluaW1hbCBkaXN0YW5jZXMpIG9yIGEgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgMyBhcmd1bWVudHM6IHRoZSBjdXJyZW50IGRpc3RhbmNlLFxuICogbWluaW1hbCBkaXN0YW5jZSwgbWF4aW11bSBkaXN0YW5jZSBhbmQgcmV0dXJucyB0cnVlIG9yIGZhbHNlIHRvIGluY2x1ZGUgb3IgZXhjbHVkZSB0aGUgbWF0Y2guXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB2aXN1YWxpemUgW2ZhbHNlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0aW5nIHZpc2FsaXphdGlvblxuICogYXMgYW4gaW1hZ2UgKHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWF0Y2hpbmdSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb3VudCBUaGUgY291bnQgb2YgbWF0Y2hlZCBlZGdlcyBvbiBib3RoIGltYWdlcy5cbiAqIFRoZSBtb3JlIG1hdGNoaW5nIGVkZ2VzIHRoZXJlIGFyZSBubyBib3RoIGltYWdlcyB0aGUgbW9yZSBzaW1pbGFyIHRoZXkgYXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvdGFsQ291bnQgVGhlIHRvdGFsIGNvdW50IG9mIG1hdGNoZWQgZWRnZXMgb24gYm90aCBpbWFnZXMuXG4gKiBJdCBpcyBlcXVhbCB0byBgY291bnRgIGlmIGBnb29kTWF0Y2hlc0ZhY3RvcmAgZG9lcyBub3QgbGltaXQgdGhlIG1hdGNoZXMsXG4gKiBvdGhlcndpc2UgaXQgY29udGFpbnMgdGhlIHRvdGFsIGNvdW50IG9mIG1hdGNoZXMgYmVmb3JlIGBnb29kTWF0Y2hlc0ZhY3RvcmAgaXNcbiAqIGFwcGxpZWQuXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gVGhpcyB2aXN1YWxpemF0aW9uIGxvb2tzIGxpa2VcbiAqIGh0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzMxMTI1NTIxLzI5NzAyNzMxLWM3OWUzMTQyLTg5NzItMTFlNy05NDdlLWRiMTA5ZDQxNTQ2OS5qcGdcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UG9pbnQ+fSBwb2ludHMxIFRoZSBhcnJheSBvZiBtYXRjaGluZyBwb2ludHMgb24gdGhlIGZpcnN0IGltYWdlXG4gKiBAcHJvcGVydHkge1JlY3R9IHJlY3QxIFRoZSBib3VuZGluZyByZWN0IGZvciB0aGUgYG1hdGNoZWRQb2ludHMxYCBzZXQgb3IgYSB6ZXJvIHJlY3RcbiAqIGlmIG5vdCBlbm91Z2ggbWF0Y2hpbmcgcG9pbnRzIGFyZSBmb3VuZFxuICogQHByb3BlcnR5IHtBcnJheTxQb2ludD59IHBvaW50czIgVGhlIGFycmF5IG9mIG1hdGNoaW5nIHBvaW50cyBvbiB0aGUgc2Vjb25kIGltYWdlXG4gKiBAcHJvcGVydHkge1JlY3R9IHJlY3QyIFRoZSBib3VuZGluZyByZWN0IGZvciB0aGUgYG1hdGNoZWRQb2ludHMyYCBzZXQgb3IgYSB6ZXJvIHJlY3RcbiAqIGlmIG5vdCBlbm91Z2ggbWF0Y2hpbmcgcG9pbnRzIGFyZSBmb3VuZFxuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY291bnQgb2YgY29tbW9uIGVkZ2VzIGJldHdlZW4gdHdvIGltYWdlcy5cbiAqIFRoZSBpbWFnZXMgbWlnaHQgYmUgcm90YXRlZCBvciByZXNpemVkIHJlbGF0aXZlbHkgdG8gZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW1nMURhdGEgVGhlIGRhdGEgb2YgdGhlIGZpcnN0IGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGltZzJEYXRhIFRoZSBkYXRhIG9mIHRoZSBzZWNvbmQgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0gez9NYXRjaGluZ09wdGlvbnN9IG9wdGlvbnMgW3t9XSBTZXQgb2YgbWF0Y2hpbmcgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtNYXRjaGluZ1Jlc3VsdH0gTWFjaGluZyByZXN1bHRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgZGV0ZWN0b3JOYW1lYCB2YWx1ZSBpcyB1bmtub3duLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZXNNYXRjaGVzIChpbWcxRGF0YSwgaW1nMkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBhd2FpdCBpbml0T3BlbkNWKCk7XG5cbiAgY29uc3Qge2RldGVjdG9yTmFtZSA9ICdPUkInLCB2aXN1YWxpemUgPSBmYWxzZSxcbiAgICAgICAgIGdvb2RNYXRjaGVzRmFjdG9yLCBtYXRjaEZ1bmMgPSAnQnJ1dGVGb3JjZSd9ID0gb3B0aW9ucztcbiAgaWYgKCFfLmluY2x1ZGVzKEFWQUlMQUJMRV9ERVRFQ1RPUlMsIGRldGVjdG9yTmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2RldGVjdG9yTmFtZX0nIGRldGVjdG9yIGlzIHVua25vd24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT25seSAke0pTT04uc3RyaW5naWZ5KEFWQUlMQUJMRV9ERVRFQ1RPUlMpfSBkZXRlY3RvcnMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgfVxuICBpZiAoIV8uaW5jbHVkZXMoQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUywgbWF0Y2hGdW5jKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7bWF0Y2hGdW5jfScgbWF0Y2hpbmcgZnVuY3Rpb24gaXMgdW5rbm93bi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPbmx5ICR7SlNPTi5zdHJpbmdpZnkoQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUyl9IG1hdGNoaW5nIGZ1bmN0aW9ucyBhcmUgc3VwcG9ydGVkLmApO1xuICB9XG5cbiAgY29uc3QgZGV0ZWN0b3IgPSBuZXcgY3ZbYCR7ZGV0ZWN0b3JOYW1lfURldGVjdG9yYF0oKTtcbiAgY29uc3QgW2ltZzEsIGltZzJdID0gYXdhaXQgQi5hbGwoW1xuICAgIGN2LmltZGVjb2RlQXN5bmMoaW1nMURhdGEpLFxuICAgIGN2LmltZGVjb2RlQXN5bmMoaW1nMkRhdGEpXG4gIF0pO1xuICBjb25zdCBbcmVzdWx0MSwgcmVzdWx0Ml0gPSBhd2FpdCBCLmFsbChbXG4gICAgZGV0ZWN0QW5kQ29tcHV0ZShpbWcxLCBkZXRlY3RvciksXG4gICAgZGV0ZWN0QW5kQ29tcHV0ZShpbWcyLCBkZXRlY3RvcilcbiAgXSk7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIHRyeSB7XG4gICAgbWF0Y2hlcyA9IGF3YWl0IGN2W2BtYXRjaCR7bWF0Y2hGdW5jfUFzeW5jYF0ocmVzdWx0MS5kZXNjcmlwdG9yLCByZXN1bHQyLmRlc2NyaXB0b3IpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhbnkgbWF0Y2hlcyBiZXR3ZWVuIHRoZSBnaXZlbiBpbWFnZXMuIFRyeSBhbm90aGVyIGRldGVjdGlvbiBhbGdvcml0aG0uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgIE9yaWdpbmFsIGVycm9yOiAke2V9YCk7XG4gIH1cbiAgY29uc3QgdG90YWxDb3VudCA9IG1hdGNoZXMubGVuZ3RoO1xuICBpZiAoaGFzVmFsdWUoZ29vZE1hdGNoZXNGYWN0b3IpKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihnb29kTWF0Y2hlc0ZhY3RvcikpIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IG1hdGNoZXMubWFwKChtYXRjaCkgPT4gbWF0Y2guZGlzdGFuY2UpO1xuICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSBfLm1pbihkaXN0YW5jZXMpO1xuICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSBfLm1heChkaXN0YW5jZXMpO1xuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXNcbiAgICAgICAgLmZpbHRlcigobWF0Y2gpID0+IGdvb2RNYXRjaGVzRmFjdG9yKG1hdGNoLmRpc3RhbmNlLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gZ29vZE1hdGNoZXNGYWN0b3IpIHtcbiAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXNcbiAgICAgICAgICAuc29ydCgobWF0Y2gxLCBtYXRjaDIpID0+IG1hdGNoMS5kaXN0YW5jZSAtIG1hdGNoMi5kaXN0YW5jZSlcbiAgICAgICAgICAuc2xpY2UoMCwgZ29vZE1hdGNoZXNGYWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGV4dHJhY3RQb2ludCA9IChrZXlQb2ludHMsIGluZGV4UHJvcGVydHlOYW1lKSA9PiAobWF0Y2gpID0+IHtcbiAgICBjb25zdCB7cHQsIHBvaW50fSA9IGtleVBvaW50c1ttYXRjaFtpbmRleFByb3BlcnR5TmFtZV1dO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdXN0YWR1ZGV3aG9oYWNrcy9vcGVuY3Y0bm9kZWpzL2lzc3Vlcy81ODRcbiAgICByZXR1cm4gKHB0IHx8IHBvaW50KTtcbiAgfTtcbiAgY29uc3QgcG9pbnRzMSA9IG1hdGNoZXMubWFwKGV4dHJhY3RQb2ludChyZXN1bHQxLmtleVBvaW50cywgJ3F1ZXJ5SWR4JykpO1xuICBjb25zdCByZWN0MSA9IGNhbGN1bGF0ZU1hdGNoZWRSZWN0KHBvaW50czEpO1xuICBjb25zdCBwb2ludHMyID0gbWF0Y2hlcy5tYXAoZXh0cmFjdFBvaW50KHJlc3VsdDIua2V5UG9pbnRzLCAndHJhaW5JZHgnKSk7XG4gIGNvbnN0IHJlY3QyID0gY2FsY3VsYXRlTWF0Y2hlZFJlY3QocG9pbnRzMik7XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHBvaW50czEsXG4gICAgcmVjdDEsXG4gICAgcG9pbnRzMixcbiAgICByZWN0MixcbiAgICB0b3RhbENvdW50LFxuICAgIGNvdW50OiBtYXRjaGVzLmxlbmd0aCxcbiAgfTtcbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IHZpc3VhbGl6YXRpb24gPSBjdi5kcmF3TWF0Y2hlcyhpbWcxLCBpbWcyLCByZXN1bHQxLmtleVBvaW50cywgcmVzdWx0Mi5rZXlQb2ludHMsIG1hdGNoZXMpO1xuICAgIGhpZ2hsaWdodFJlZ2lvbih2aXN1YWxpemF0aW9uLCByZWN0MSk7XG4gICAgaGlnaGxpZ2h0UmVnaW9uKHZpc3VhbGl6YXRpb24sIHtcbiAgICAgIHg6IGltZzEuY29scyArIHJlY3QyLngsXG4gICAgICB5OiByZWN0Mi55LFxuICAgICAgd2lkdGg6IHJlY3QyLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0Mi5oZWlnaHRcbiAgICB9KTtcbiAgICByZXN1bHQudmlzdWFsaXphdGlvbiA9IGF3YWl0IGN2LmltZW5jb2RlQXN5bmMoJy5wbmcnLCB2aXN1YWxpemF0aW9uKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbWlsYXJpdHlPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB2aXN1YWxpemUgW2ZhbHNlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0aW5nIHZpc2FsaXphdGlvblxuICogYXMgYW4gaW1hZ2UgKHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCBbVE1fQ0NPRUZGX05PUk1FRF0gVGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIG1hdGNoaW5nIG1ldGhvZC5cbiAqIEFjY2VwdGFibGUgdmFsdWVzIGFyZTpcbiAqIC0gVE1fQ0NPRUZGXG4gKiAtIFRNX0NDT0VGRl9OT1JNRUQgKGRlZmF1bHQpXG4gKiAtIFRNX0NDT1JSXG4gKiAtIFRNX0NDT1JSX05PUk1FRFxuICogLSBUTV9TUURJRkZcbiAqIC0gVE1fU1FESUZGX05PUk1FRFxuICogUmVhZCBodHRwczovL2RvY3Mub3BlbmN2Lm9yZy8zLjAtYmV0YS9kb2MvcHlfdHV0b3JpYWxzL3B5X2ltZ3Byb2MvcHlfdGVtcGxhdGVfbWF0Y2hpbmcvcHlfdGVtcGxhdGVfbWF0Y2hpbmcuaHRtbFxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbWlsYXJpdHlSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY29yZSBUaGUgc2ltaWxhcml0eSBzY29yZSBhcyBhIGZsb2F0IG51bWJlciBpbiByYW5nZSBbMC4wLCAxLjBdLlxuICogMS4wIGlzIHRoZSBoaWdoZXN0IHNjb3JlIChtZWFucyBib3RoIGltYWdlcyBhcmUgdG90YWxseSBlcXVhbCkuXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gVGhpcyBpbWFnZSBpbmNsdWRlcyBib3RoIGlucHV0IHBpY3R1cmVzIHdoZXJlXG4gKiBkaWZmZXJlbmNlIHJlZ2lvbnMgYXJlIGhpZ2hsaWdodGVkIHdpdGggcmVjdGFuZ2xlcy5cbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgc2NvcmUgYmV0d2VlbiB0d28gaW1hZ2VzLlxuICogSXQgaXMgZXhwZWN0ZWQsIHRoYXQgYm90aCBpbWFnZXMgaGF2ZSB0aGUgc2FtZSByZXNvbHV0aW9uLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcxRGF0YSBUaGUgZGF0YSBvZiB0aGUgZmlyc3QgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW1nMkRhdGEgVGhlIGRhdGEgb2YgdGhlIHNlY29uZCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7P1NpbWlsYXJpdHlPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIHNpbWlsYXJpdHkgY2FsY3VsYXRpb24gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtTaW1pbGFyaXR5UmVzdWx0fSBUaGUgY2FsY3VsYXRpb24gcmVzdWx0XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGdpdmVuIGltYWdlcyBoYXZlIGRpZmZlcmVudCByZXNvbHV0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZXNTaW1pbGFyaXR5IChpbWcxRGF0YSwgaW1nMkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBhd2FpdCBpbml0T3BlbkNWKCk7XG5cbiAgY29uc3Qge1xuICAgIG1ldGhvZCA9IERFRkFVTFRfTUFUQ0hJTkdfTUVUSE9ELFxuICAgIHZpc3VhbGl6ZSA9IGZhbHNlLFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IFt0ZW1wbGF0ZSwgcmVmZXJlbmNlXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzFEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzJEYXRhKVxuICBdKTtcbiAgaWYgKHRlbXBsYXRlLnJvd3MgIT09IHJlZmVyZW5jZS5yb3dzIHx8IHRlbXBsYXRlLmNvbHMgIT09IHJlZmVyZW5jZS5jb2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaXplIGluIG9yZGVyIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnY2FsY3VsYXRlIHRoZSBzaW1pbGFyaXR5IHNjb3JlLicpO1xuICB9XG4gIFt0ZW1wbGF0ZSwgcmVmZXJlbmNlXSA9IGF3YWl0IEIuYWxsKFtcbiAgICB0ZW1wbGF0ZS5jb252ZXJ0VG9Bc3luYyhjdi5DVl84VUMzKSxcbiAgICByZWZlcmVuY2UuY29udmVydFRvQXN5bmMoY3YuQ1ZfOFVDMylcbiAgXSk7XG5cbiAgbGV0IG1hdGNoZWQ7XG4gIHRyeSB7XG4gICAgbWF0Y2hlZCA9IGF3YWl0IHJlZmVyZW5jZS5tYXRjaFRlbXBsYXRlQXN5bmModGVtcGxhdGUsIHRvTWF0Y2hpbmdNZXRob2QobWV0aG9kKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZWZlcmVuY2UgaW1hZ2UgZGlkIG5vdCBtYXRjaCB0byB0aGUgdGVtcGxhdGUgb25lLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgY29uc3QgbWluTWF4ID0gYXdhaXQgbWF0Y2hlZC5taW5NYXhMb2NBc3luYygpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgc2NvcmU6IG1pbk1heC5tYXhWYWxcbiAgfTtcbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IHJlc3VsdE1hdCA9IG5ldyBjdi5NYXQodGVtcGxhdGUucm93cywgdGVtcGxhdGUuY29scyAqIDIsIGN2LkNWXzhVQzMpO1xuICAgIGF3YWl0IEIuYWxsKFtcbiAgICAgIHJlZmVyZW5jZS5jb3B5VG9Bc3luYyhcbiAgICAgICAgcmVzdWx0TWF0LmdldFJlZ2lvbihuZXcgY3YuUmVjdCgwLCAwLCByZWZlcmVuY2UuY29scywgcmVmZXJlbmNlLnJvd3MpKSksXG4gICAgICB0ZW1wbGF0ZS5jb3B5VG9Bc3luYyhcbiAgICAgICAgcmVzdWx0TWF0LmdldFJlZ2lvbihuZXcgY3YuUmVjdChyZWZlcmVuY2UuY29scywgMCwgdGVtcGxhdGUuY29scywgdGVtcGxhdGUucm93cykpKVxuICAgIF0pO1xuICAgIGxldCBtYXNrID0gcmVmZXJlbmNlLmFic2RpZmYodGVtcGxhdGUpO1xuICAgIG1hc2sgPSBhd2FpdCBtYXNrLmN2dENvbG9yQXN5bmMoY3YuQ09MT1JfQkdSMkdSQVkpO1xuICAgIGxldCBjb250b3VycyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBtYXNrID0gYXdhaXQgbWFzay50aHJlc2hvbGRBc3luYygxMjgsIDI1NSwgY3YuVEhSRVNIX0JJTkFSWSB8IGN2LlRIUkVTSF9PVFNVKTtcbiAgICAgIGNvbnRvdXJzID0gYXdhaXQgbWFzay5maW5kQ29udG91cnNBc3luYyhjdi5SRVRSX0VYVEVSTkFMLCBjdi5DSEFJTl9BUFBST1hfU0lNUExFKTtcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIC8vIE5vIGNvbnRvdXJzIGNhbiBiZSBmb3VuZCwgd2hpY2ggbWVhbnMsIG1vc3QgbGlrZWx5LCB0aGF0IGltYWdlcyBhcmUgZXF1YWxcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250b3VyIG9mIGNvbnRvdXJzKSB7XG4gICAgICBjb25zdCBib3VuZGluZ1JlY3QgPSBjb250b3VyLmJvdW5kaW5nUmVjdCgpO1xuICAgICAgaGlnaGxpZ2h0UmVnaW9uKHJlc3VsdE1hdCwgYm91bmRpbmdSZWN0KTtcbiAgICAgIGhpZ2hsaWdodFJlZ2lvbihyZXN1bHRNYXQsIHtcbiAgICAgICAgeDogcmVmZXJlbmNlLmNvbHMgKyBib3VuZGluZ1JlY3QueCxcbiAgICAgICAgeTogYm91bmRpbmdSZWN0LnksXG4gICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIHJlc3VsdE1hdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPY2N1cnJlbmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdmlzdWFsaXplIFtmYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdGluZyB2aXNhbGl6YXRpb25cbiAqIGFzIGFuIGltYWdlICh1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqIEBwcm9wZXJ0eSB7P2Zsb2F0fSB0aHJlc2hvbGQgWzAuNV0gQXQgd2hhdCBub3JtYWxpemVkIHRocmVzaG9sZCB0byByZWplY3RcbiAqIGEgbWF0Y2hcbiAqIEBwcm9wZXJ0eSB7P2Zsb2F0fSBtdWx0aXBsZSBbZmFsc2VdIGZpbmQgbXVsdGlwbGUgbWF0Y2hlcyBpbiB0aGUgaW1hZ2VcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQgWzEwXSBUaGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiBtYXRjaGVzIHdlIGNvbnNpZGVyXG4gKiB0byBiZSBwYXJ0IG9mIHRoZSBzYW1lIHRlbXBsYXRlIG1hdGNoXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPY2N1cnJlbmNlUmVzdWx0XG4gKiBAcHJvcGVydHkge1JlY3R9IHJlY3QgVGhlIHJlZ2lvbiBvZiB0aGUgcGFydGlhbCBpbWFnZSBvY2N1cmVuY2VcbiAqIG9uIHRoZSBmdWxsIGltYWdlXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gT24gdGhpcyBpbWFnZSB0aGUgbWF0Y2hpbmdcbiAqIHJlZ2lvbiBpcyBoaWdobGlnaHRlZCB3aXRoIGEgcmVjdGFuZ2xlLiBJZiB0aGUgbXVsdGlwbGUgb3B0aW9uIGlzIHBhc3NlZCxcbiAqIGFsbCByZXN1bHRzIGFyZSBoaWdobGlnaHRlZCBoZXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjb3JlIFRoZSBzaW1pbGFyaXR5IHNjb3JlIGFzIGEgZmxvYXQgbnVtYmVyIGluIHJhbmdlIFswLjAsIDEuMF0uXG4gKiAxLjAgaXMgdGhlIGhpZ2hlc3Qgc2NvcmUgKG1lYW5zIGJvdGggaW1hZ2VzIGFyZSB0b3RhbGx5IGVxdWFsKS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2NjdXJyZW5jZVJlc3VsdD59IG11bHRpcGxlIFRoZSBhcnJheSBvZiBtYXRjaGluZyBPY2N1cmVuY2VSZXN1bHRzXG4gKiAtIG9ubHkgd2hlbiBtdWx0aXBsZSBvcHRpb24gaXMgcGFzc2VkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWV0aG9kIFtUTV9DQ09FRkZfTk9STUVEXSBUaGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUgbWF0Y2hpbmcgbWV0aG9kLlxuICogQWNjZXB0YWJsZSB2YWx1ZXMgYXJlOlxuICogLSBUTV9DQ09FRkZcbiAqIC0gVE1fQ0NPRUZGX05PUk1FRCAoZGVmYXVsdClcbiAqIC0gVE1fQ0NPUlJcbiAqIC0gVE1fQ0NPUlJfTk9STUVEXG4gKiAtIFRNX1NRRElGRlxuICogLSBUTV9TUURJRkZfTk9STUVEXG4gKiBSZWFkIGh0dHBzOi8vZG9jcy5vcGVuY3Yub3JnLzMuMC1iZXRhL2RvYy9weV90dXRvcmlhbHMvcHlfaW1ncHJvYy9weV90ZW1wbGF0ZV9tYXRjaGluZy9weV90ZW1wbGF0ZV9tYXRjaGluZy5odG1sXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgb2NjdXJyZW5jZSBwb3NpdGlvbiBvZiBhIHBhcnRpYWwgaW1hZ2UgaW4gdGhlIGZ1bGxcbiAqIGltYWdlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBmdWxsSW1nRGF0YSBUaGUgZGF0YSBvZiB0aGUgZnVsbCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBwYXJ0aWFsSW1nRGF0YSBUaGUgZGF0YSBvZiB0aGUgcGFydGlhbCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7P09jY3VycmVuY2VPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIG9jY3VycmVuY2UgY2FsY3VsYXRpb24gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPY2N1cnJlbmNlUmVzdWx0fVxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIG9jY3VycmVuY2VzIG9mIHRoZSBwYXJ0aWFsIGltYWdlIGNhbiBiZSBmb3VuZCBpbiB0aGUgZnVsbCBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZU9jY3VycmVuY2UgKGZ1bGxJbWdEYXRhLCBwYXJ0aWFsSW1nRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGF3YWl0IGluaXRPcGVuQ1YoKTtcblxuICBjb25zdCB7XG4gICAgdmlzdWFsaXplID0gZmFsc2UsXG4gICAgdGhyZXNob2xkID0gREVGQVVMVF9NQVRDSF9USFJFU0hPTEQsXG4gICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICBtYXRjaE5laWdoYm91clRocmVzaG9sZCA9IE1BVENIX05FSUdIQk9VUl9USFJFU0hPTEQsXG4gICAgbWV0aG9kID0gREVGQVVMVF9NQVRDSElOR19NRVRIT0QsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtmdWxsSW1nLCBwYXJ0aWFsSW1nXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGZ1bGxJbWdEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKHBhcnRpYWxJbWdEYXRhKVxuICBdKTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBsZXQgdmlzdWFsaXphdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBtYXRjaGVkID0gYXdhaXQgZnVsbEltZy5tYXRjaFRlbXBsYXRlQXN5bmMocGFydGlhbEltZywgdG9NYXRjaGluZ01ldGhvZChtZXRob2QpKTtcbiAgICBjb25zdCBtaW5NYXggPSBhd2FpdCBtYXRjaGVkLm1pbk1heExvY0FzeW5jKCk7XG5cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIGNvbnN0IG5vblplcm9NYXRjaFJlc3VsdHMgPSBtYXRjaGVkLnRocmVzaG9sZCh0aHJlc2hvbGQsIDEsIGN2LlRIUkVTSF9CSU5BUlkpXG4gICAgICAgIC5jb252ZXJ0VG8oY3YuQ1ZfOFUpXG4gICAgICAgIC5maW5kTm9uWmVybygpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGZpbHRlck5lYXJNYXRjaGVzKG5vblplcm9NYXRjaFJlc3VsdHMsIG1hdGNoTmVpZ2hib3VyVGhyZXNob2xkKTtcblxuICAgICAgZm9yIChjb25zdCB7eCwgeX0gb2YgbWF0Y2hlcykge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIHNjb3JlOiBtYXRjaGVkLmF0KHksIHgpLFxuICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICB3aWR0aDogcGFydGlhbEltZy5jb2xzLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJ0aWFsSW1nLnJvd3NcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluTWF4Lm1heFZhbCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGNvbnN0IHt4LCB5fSA9IG1ldGhvZC5pbmNsdWRlcygnU1FESUZGJykgPyBtaW5NYXgubWluTG9jIDogbWluTWF4Lm1heExvYztcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHNjb3JlOiBtaW5NYXgubWF4VmFsLFxuICAgICAgICByZWN0OiB7XG4gICAgICAgICAgeCwgeSxcbiAgICAgICAgICB3aWR0aDogcGFydGlhbEltZy5jb2xzLFxuICAgICAgICAgIGhlaWdodDogcGFydGlhbEltZy5yb3dzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChfLmlzRW1wdHkocmVzdWx0cykpIHtcbiAgICAgIC8vIEJlbG93IGVycm9yIG1lc3NhZ2UsIGBDYW5ub3QgZmluZCBhbnkgb2NjdXJyZW5jZXNgIGlzIHJlZmVyZW5jZWQgaW4gZmluZCBieSBpbWFnZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXRjaCB0aHJlc2hvbGQ6ICR7dGhyZXNob2xkfS4gSGlnaGVzdCBtYXRjaCB2YWx1ZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgZm91bmQgd2FzICR7bWluTWF4Lm1heFZhbH1gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBCZWxvdyBlcnJvciBtZXNzYWdlLCBgQ2Fubm90IGZpbmQgYW55IG9jY3VycmVuY2VzYCBpcyByZWZlcmVuY2VkIGluIGZpbmQgYnkgaW1hZ2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFueSBvY2N1cnJlbmNlcyBvZiB0aGUgcGFydGlhbCBpbWFnZSBpbiB0aGUgZnVsbCBpbWFnZS4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG5cbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IGZ1bGxIaWdobGlnaHRlZEltYWdlID0gZnVsbEltZy5jb3B5KCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICBjb25zdCBzaW5nbGVIaWdobGlnaHRlZEltYWdlID0gZnVsbEltZy5jb3B5KCk7XG5cbiAgICAgIGhpZ2hsaWdodFJlZ2lvbihzaW5nbGVIaWdobGlnaHRlZEltYWdlLCByZXN1bHQucmVjdCk7XG4gICAgICBoaWdobGlnaHRSZWdpb24oZnVsbEhpZ2hsaWdodGVkSW1hZ2UsIHJlc3VsdC5yZWN0KTtcbiAgICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIHNpbmdsZUhpZ2hsaWdodGVkSW1hZ2UpO1xuICAgIH1cbiAgICB2aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIGZ1bGxIaWdobGlnaHRlZEltYWdlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVjdDogcmVzdWx0c1swXS5yZWN0LFxuICAgIHNjb3JlOiByZXN1bHRzWzBdLnNjb3JlLFxuICAgIHZpc3VhbGl6YXRpb24sXG4gICAgbXVsdGlwbGU6IHJlc3VsdHNcbiAgfTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IG1hdGNoIHJlc3VsdHMgd2hpY2ggaGF2ZSBhIG1hdGNoZWQgbmVpZ2hib3VyXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG5vblplcm9NYXRjaFJlc3VsdHMgbWF0cml4IG9mIGltYWdlIG1hdGNoIHJlc3VsdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXRjaE5laWdoYm91clRocmVzaG9sZCBUaGUgcGl4ZWwgZGlzdGFuY2Ugd2l0aGluIHdoaWNoIHdlXG4gKiBjb25zaWRlciBhbiBlbGVtZW50IGJlaW5nIGEgbmVpZ2hib3VyIG9mIGFuIGV4aXN0aW5nIG1hdGNoXG4gKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IHRoZSBmaWx0ZXJlZCBhcnJheSBvZiBtYXRjaGVkIHBvaW50c1xuICovXG5mdW5jdGlvbiBmaWx0ZXJOZWFyTWF0Y2hlcyAobm9uWmVyb01hdGNoUmVzdWx0cywgbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQpIHtcbiAgcmV0dXJuIG5vblplcm9NYXRjaFJlc3VsdHMucmVkdWNlKChhY2MsIGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIWFjYy5zb21lKChtYXRjaCkgPT4gZGlzdGFuY2UobWF0Y2gsIGVsZW1lbnQpIDw9IG1hdGNoTmVpZ2hib3VyVGhyZXNob2xkKSkge1xuICAgICAgYWNjLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludDEgVGhlIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludDIgVGhlIHNlY29uZCBwb2ludFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UgKHBvaW50MSwgcG9pbnQyKSB7XG4gIGNvbnN0IGEyID0gTWF0aC5wb3coKHBvaW50MS54IC0gcG9pbnQyLngpLCAyKTtcbiAgY29uc3QgYjIgPSBNYXRoLnBvdygocG9pbnQxLnkgLSBwb2ludDIueSksIDIpO1xuICByZXR1cm4gTWF0aC5zcXJ0KGEyICsgYjIpO1xufVxuXG4vKipcbiAqIENyb3AgdGhlIGltYWdlIGJ5IGdpdmVuIHJlY3RhbmdsZSAodXNlIGJhc2U2NCBzdHJpbmcgYXMgaW5wdXQgYW5kIG91dHB1dClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0SW1hZ2UgVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKiBAcGFyYW0ge1JlZ2lvbn0gcmVjdCBUaGUgc2VsZWN0ZWQgcmVnaW9uIG9mIGltYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiBjcm9wcGVkIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyb3BCYXNlNjRJbWFnZSAoYmFzZTY0SW1hZ2UsIHJlY3QpIHtcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBiYXNlNjRUb0ltYWdlKGJhc2U2NEltYWdlKTtcbiAgY3JvcEltYWdlKGltYWdlLCByZWN0KTtcbiAgcmV0dXJuIGF3YWl0IGltYWdlVG9CYXNlNjQoaW1hZ2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBuZ2pzIGltYWdlIGZyb20gZ2l2ZW4gYmFzZTY0IGltYWdlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NEltYWdlIFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICogQHJldHVybiB7UE5HfSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJhc2U2NFRvSW1hZ2UgKGJhc2U2NEltYWdlKSB7XG4gIGNvbnN0IGltYWdlQnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0SW1hZ2UsICdiYXNlNjQnKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBQTkcoe2ZpbHRlclR5cGU6IFNDQU5MSU5FX0ZJTFRFUl9NRVRIT0R9KTtcbiAgICBpbWFnZS5wYXJzZShpbWFnZUJ1ZmZlciwgKGVyciwgaW1hZ2UpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzdHJpbmcgZm9yIGdpdmVuIGltYWdlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7UE5HfSBpbWFnZSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBpbWFnZVRvQmFzZTY0IChpbWFnZSkge1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGltYWdlLnBhY2soKVxuICAgIC5vbignZGF0YScsIChjaHVuaykgPT4gY2h1bmtzLnB1c2goY2h1bmspKS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JvcCB0aGUgaW1hZ2UgYnkgZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHtQTkd9IGltYWdlIFRoZSBpbWFnZSB0byBtdXRhdGUgYnkgY3JvcHBpbmdcbiAqIEBwYXJhbSB7UmVnaW9ufSByZWN0IFRoZSBzZWxlY3RlZCByZWdpb24gb2YgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gY3JvcEltYWdlIChpbWFnZSwgcmVjdCkge1xuICBjb25zdCBpbWFnZVJlY3QgPSB7d2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodH07XG4gIGNvbnN0IGludGVyUmVjdCA9IGdldFJlY3RJbnRlcnNlY3Rpb24ocmVjdCwgaW1hZ2VSZWN0KTtcbiAgaWYgKGludGVyUmVjdC53aWR0aCA8IHJlY3Qud2lkdGggfHwgaW50ZXJSZWN0LmhlaWdodCA8IHJlY3QuaGVpZ2h0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JvcCAke0pTT04uc3RyaW5naWZ5KHJlY3QpfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoaW1hZ2VSZWN0KX0gYmVjYXVzZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlbSB3YXMgbm90IHRoZSBzaXplIG9mIHRoZSByZWN0YCk7XG4gIH1cblxuICBjb25zdCBmaXJzdFZlcnRpY2FsUGl4ZWwgPSBpbnRlclJlY3QudG9wO1xuICBjb25zdCBsYXN0VmVydGljYWxQaXhlbCA9IGludGVyUmVjdC50b3AgKyBpbnRlclJlY3QuaGVpZ2h0O1xuXG4gIGNvbnN0IGZpcnN0SG9yaXpvbnRhbFBpeGVsID0gaW50ZXJSZWN0LmxlZnQ7XG4gIGNvbnN0IGxhc3RIb3Jpem9udGFsUGl4ZWwgPSBpbnRlclJlY3QubGVmdCArIGludGVyUmVjdC53aWR0aDtcblxuICBjb25zdCBjcm9wcGVkQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgeSA9IGZpcnN0VmVydGljYWxQaXhlbDsgeSA8IGxhc3RWZXJ0aWNhbFBpeGVsOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gZmlyc3RIb3Jpem9udGFsUGl4ZWw7IHggPCBsYXN0SG9yaXpvbnRhbFBpeGVsOyB4KyspIHtcbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayA9IChpbWFnZVJlY3Qud2lkdGggKiB5ICsgeCkgPDwgMjtcbiAgICAgIGZvciAobGV0IGJ5dGVJZHggPSAwOyBieXRlSWR4IDwgQllURVNfSU5fUElYRUxfQkxPQ0s7IGJ5dGVJZHgrKykge1xuICAgICAgICBjcm9wcGVkQXJyYXkucHVzaChpbWFnZS5kYXRhW2ZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayArIGJ5dGVJZHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbWFnZS5kYXRhID0gQnVmZmVyLmZyb20oY3JvcHBlZEFycmF5KTtcbiAgaW1hZ2Uud2lkdGggPSBpbnRlclJlY3Qud2lkdGg7XG4gIGltYWdlLmhlaWdodCA9IGludGVyUmVjdC5oZWlnaHQ7XG4gIHJldHVybiBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdEludGVyc2VjdGlvbiAocmVjdCwgaW1hZ2VTaXplKSB7XG4gIGNvbnN0IGxlZnQgPSByZWN0LmxlZnQgPj0gaW1hZ2VTaXplLndpZHRoID8gaW1hZ2VTaXplLndpZHRoIDogcmVjdC5sZWZ0O1xuICBjb25zdCB0b3AgPSByZWN0LnRvcCA+PSBpbWFnZVNpemUuaGVpZ2h0ID8gaW1hZ2VTaXplLmhlaWdodCA6IHJlY3QudG9wO1xuICBjb25zdCB3aWR0aCA9IGltYWdlU2l6ZS53aWR0aCA+PSAobGVmdCArIHJlY3Qud2lkdGgpID8gcmVjdC53aWR0aCA6IChpbWFnZVNpemUud2lkdGggLSBsZWZ0KTtcbiAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VTaXplLmhlaWdodCA+PSAodG9wICsgcmVjdC5oZWlnaHQpID8gcmVjdC5oZWlnaHQgOiAoaW1hZ2VTaXplLmhlaWdodCAtIHRvcCk7XG4gIHJldHVybiB7bGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZXhwb3J0IHtcbiAgY3JvcEJhc2U2NEltYWdlLCBiYXNlNjRUb0ltYWdlLCBpbWFnZVRvQmFzZTY0LCBjcm9wSW1hZ2UsIGdldEltYWdlc01hdGNoZXMsXG4gIGdldEltYWdlc1NpbWlsYXJpdHksIGdldEltYWdlT2NjdXJyZW5jZSwgZ2V0SmltcEltYWdlLCBNSU1FX0pQRUcsIE1JTUVfUE5HLFxuICBNSU1FX0JNUCxcbn07XG4iXSwiZmlsZSI6ImxpYi9pbWFnZS11dGlsLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
